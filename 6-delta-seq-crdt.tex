
\chapter{Séquences répliquées synchronisées par différences}\label{ch:dotted-logootsplit}

\minitoc{}
\bigskip

Une séquence est une abstraction utile à la conception d'applications de collaboration tel que des éditeurs collaboratifs de texte \autocite{2017_nicolas-mute-demo,nedelec2016_crate}.
\emph{EtherPad}\footnote{\url{https://etherpad.org}}, \emph{Google Docs}\footnote{\url{https://docs.google.com}}, et \emph{ShareLaTeX}\footnote{aujourd'hui fusionne avec Overleaf~: \url{https://www.overleaf.com}} sont des exemples d'éditeurs collaboratifs de texte.
Ils ont répandu l'usage de l'édition collaborative au sein des communautés scientifiques, et au sein des organisations économiques, sociales, et politiques.

Ces éditeurs collaboratifs reposent sur des infrastructures centralisés.
Les collaborateur·ice·s sont connecté·e·s à un serveur.
Toute modification qu'elles et ils effectuent sur le document textuel est transmise au serveur.
Le serveur transmet alors une mise-à-jour à l'ensemble des collaborateur·ice·s.
Cette architecture engendre des problèmes de confidentialité, de vie privée, de censure, et de sécurité.
Elle souffre également d'un problème de disponibilité, de latences élevées, d'un passage à l'échelle pauvre,
et d'une restriction des formes que peut prendre une collaboration.

Afin de répondre à ces problématiques, de nouveaux travaux proposent de fonder les éditeurs collaboratifs sur des protocoles de réplication optimiste de séquences de caractères~\autocite{oster_2006_woot,weiss_2009_logoot,preguica_2009_treedoc,roh_2011_rga}.
Chaque collaborateur·ice dispose d'une copie du document sur-laquelle il ou elle exécute ses opérations.
L'exécution des opérations génère des messages qui sont intégrés à la copie.
Les messages sont transmis aux autres collaborateur·ice·s qui les intègrent à leur tour.

Les séquences répliquées proposées dans la littérature sont synchronisées par opérations.
Lorsqu'un pair exécute une opération sur sa copie, il dérive un message qui encapsule une opération intégrable sur sa copie et les copies des autres pairs.
Une opération intégrable dépend d'un ensemble d'opérations intégrables.
Par exemple, la suppression d'une valeur doit être intégrée après son insertion.
La détection de ces dépendances peut être complexe.
Pour simplifier, les protocoles de réplication de séquences supposent généralement une livraison causale des opérations intégrables.

La livraison causale des opérations introduit des latences dans l'ensemble du système.
Il suffit qu'une opération ne soit pas livrée pour empêcher la livraison des opérations intégrables qui dépendent sur elle.
Ces latences peuvent compromettre des sessions de collaboration en simultané en augmentant le risque d'apparition de conflits de modification.
Les collaborateur·ice·s peuvent adopter des stratégies pour limiter les conflits et ne plus prendre pleinement avantage de l'édition collaborative en simultané~\autocite{ignat2014_delayeffect}.
Ces problèmes limitent également le passage à l'échelle à des sessions de collaborations qui incluent des centaines de collaborateur·ice·s.

La livraison causale des opérations limite la conception de protocoles de synchronisation qui pourraient tirer avantage d'un modèle de livraison aux hypothèses plus faibles.
Les hypothèses peuvent être trop fortes pour certains environnements dont les ressources sont contraintes.

La synchronisation par états résout ces problèmes.
Elle est particulièrement adaptée à des types de données répliquées simples tel que les compteurs \autocite{almeida_2018_delta-crdt-revisited}.
Elle consiste à transmettre directement l'état de la copie aux autres pairs.
Les pairs fusionnent les états qu'ils reçoivent à leur copie.
Des états peuvent être omis, dupliqués, et fusionnés dans un ordre quelconque.
La résilience de ce modèle de synchronisation réduit considérablement les hypothèses de livraison des messages~: la livraison des états peut être non-fiable et non ordonnée.
La synchronisation par états présente toutefois un sur-coût trop important pour des types de données répliquées plus élaborés tel que les ensembles ou les séquences.
Au fur et à mesure que l'état croit, le coût de communication et de fusion s'accroît~\autocite{enes_2018_efficient-sync-state-based-crdt}.

La synchronisation par différences d'états~\autocite{almeida_2018_delta-crdt-revisited} a montré qu'il était possible de conserver les avantages de la synchronisation par états tout en réduisant leur coût en communication et en fusion~\autocite{enes_2018_efficient-sync-state-based-crdt}.
Lorsqu'un pair exécute une opération il dérive un message qui contient une différence d'état.
Les protocoles sont conçues de telle manière à ce que cette différence soit bien plus petite que l'état complet.
Les différences d'états doivent être transmis au moins une fois.
Les hypothèses de livraison des messages restent faibles.
Ce qui ouvre à un large espace de conception de protocole de livraison de messages.

Ces observations nous conduisent à formuler la question de recherche suivante~: un protocole synchronisé par différences d'états pour l'édition collaborative en simultané de texte existe-il~?

Dans un premier temps nous présentons un état de l'art sur les séquences répliquées.
Dans un second temps nous présentons un protocole de réplication de séquences par différences d'états.
Ce protocole est présenté de manière générique à l'aide d'un formalisme que nous introduisons.


\section{État de l'art}\label{sec:state-art-seq}

Dans cette section, nous présentons le type abstrait de données répliquées Séquence, ainsi que les séquences répliquées proposées dans la littérature.
Pour finir nous présentons une classification des séquences répliquées proposées dans la littérature.

\subsection{Séquences répliquées sans conflits}\label{subsec:replseq}

Une séquence arrange de manière ordonnée des valeurs.
La composition de la séquence évolue au cours du temps~:
des valeurs peuvent être insérées et supprimées de la séquence.
Pour ce faire, le type abstrait Séquence dispose d'une opération d'insertion $\trm{ins}$ et d'une opération de suppression $\trm{del}$.
Il dispose également d'une opération de lecture $\trm{rd}$.
L'exécution de l'opération $\trm{ins}(n, v)$ insère la valeur $v$ avant la $n$-ème valeur de la séquence.
L'indexage des valeurs commence à $0$ et la valeur $v$ est pris dans un ensemble $V$.
Ainsi, l'insertion d'une valeur en $n = 0$ revient à insérer la valeur en début de séquence.
Lorsque $n$ est supérieur ou égal à la taille de la séquence, la valeur est insérée en fin de séquence.
L'exécution de l'opération $\trm{del}(n)$ supprime la $n$-ème valeur.
Si $n$ ne correspond pas à l'indice d'une valeur, la dernière valeur est supprimée.
Une lecture $\trm{rd}$ récupère le n-uplet de valeurs qui représente la séquence.
Si les valeurs sont des caractères, ce n-uplet est une chaîne de caractère.
$V^{n \in \mathbb{N}_0}$ correspond à l'ensemble des n-uplets de valeurs prises dans $V$.
La signature syntaxique du type abstrait Séquence est ainsi spécifiée comme suit~:
%
\begin{align*}
&\trm{Op}_{\trm{Seq}\tuple*{V}} \defeq \set*{\trm{ins}(n, v), \trm{del}(n), \trm{rd} \given v \in V \land n \in \mathbb{N}_0}\\
&\trm{Val}_{\trm{Seq}\tuple*{V}} \defeq V^{n \in \mathbb{N}_0}
\end{align*}

Pour simplifier les illustrations, nous introduisons l'opération $\trm{ins}(n, \tuple*{v_1,\dotsc,v_k})$ qui ajoute le n-uplet de valeurs $\tuple*{v_1,\dotsc,v_k}$ avant la $n$-ème valeur.
Cette opération revient à exécuter $k$ opérations d'insertion qui se succèdent $o_1 \pre \dotsb \pre o_k$ avec $\trm{call}(o_i) = \trm{ins}(n+i-1, v_i)$ et $1 \leq i \leq k$.
Nous employons cette opération uniquement dans les illustrations.
La \autoref{fig:seq-example} donne un exemple d'utilisation de ces opérations et suit la spécification usuelle d'une séquence.

\begin{figure}[htb]
    \newcommand*\hsep{1.2}
    \centering
    \begin{tikzpicture}
        % Peers
        \path node (A) {$p_A$}
        ;
        % Timeline ends
        \path (12*\hsep,0) coordinate (aend)
        ;
        % Events
        \path (A)
            to +(2*\hsep,0) node[
                label={above:$\trm{ins}(0, \textit{lady})$}
            ] (a1) {$a_1$}
            to +(4*\hsep,0) node[
                label={above:$\trm{ins}(3, \textsf{'\textit{i}'})$}
            ] (a5) {$a_2$}
            to +(6*\hsep,0) node[
                label={above:$\trm{del}(4)$}
            ] (a6) {$a_3$}
            to +(8*\hsep,0) node[
                label={above:$\trm{ins}(4, \textit{es})$}
            ] (a7) {$a_4$}
            to +(10*\hsep,0) node[
                label={above:$\trm{rd} \textit{ladies}$}
            ] (a9) {$a_6$}
        ;
        % Timelines
        \foreach \src/\dest in {A/a1,a9/aend}
            \draw (\src) edge[timeline] (\dest);
        % Precdence
        \foreach \src/\dest in {a1/a5,a5/a6,a6/a7,a7/a9}
            \draw[pre] (\src) to (\dest);
    \end{tikzpicture}
    \caption[Séquence répliquée de caractères modifiée et interrogée par un seul pair]{Séquence répliquée de caractères modifiée et interrogée par un seul pair.
    La séquence suit la spécification habituelle d'une séquence non-répliquée.}\label{fig:seq-example}
\end{figure}

L'utilisation d'une séquence classique n'est pas adaptée à l'édition collaborative.
La réplication optimiste de séquences permet à plusieurs pairs de modifier et d'interroger à tout moment une même séquence.
Chaque pair possède une copie de la séquence sur laquelle il exécute immédiatement ses opérations de modification et d'interrogation.
Dans la \autoref{sec:crdt-spec} nous avons montré que les opérations non-commutatives conduisent à des conflits d'intention si leurs effets usuels sont intégrés sans traitement particulier.
Il s'agit d'opérations incompatibles.
Les opérations de modifications d'une séquence reposent sur des indices d'insertion et de suppression.
L'indice associé à une valeur est susceptible de changer après l'exécution d'une opération.
Lorsqu'une valeur est insérée (respectivement supprimée) avant la $n$-ème valeur, cette dernière devient la $n+1$-ème valeur (respectivement la $n-1$-ème valeur).
Il en résulte que la majorité des opérations sont incompatibles.
Seules deux suppressions qui affectent le même indice sont compatibles.
Dans la lignée des travaux sur la réplication optimiste de séquences~\autocite{oster_2006_woot,sun_1998_cci}, nous soutenons qu'un pair ne souhaite pas insérer une valeur avant la n-ème valeur ou supprimer la n-ème valeur~:
un pair souhaite insérer une valeur entre deux autres valeurs et supprimer une valeur bien déterminée.
Dans la \autoref{fig:seq-example}, l'intention de l'opération $a_5$ est d'insérer $\textsf{'\textit{i}'}$ entre $\textsf{'\textit{d}'}$ et $\textsf{'\textit{y}'}$.

Dans une séquence, il est toujours possible d'insérer une valeur quelconque entre deux autres valeurs.
L'ordre formé entre les valeurs est donc dense.
Dans une séquence répliquée deux valeurs peuvent être insérées en parallèle entre un même couple de valeurs.
Les deux valeurs insérées en parallèle ne sont pas ordonnées entre-elles.
L'ordre entre les valeurs est donc partiel.
La séquence est une extension linéaire de cet ordre partiel.
Pour obtenir des copies convergentes de la séquence partagée, cette extension linéaire doit être déterminée par conception.

Une spécification complète d'une séquence répliquée détermine l'ordre total entre les valeurs.
Elle spécifie notamment l'ordre entre deux valeurs insérées en parallèle au même emplacement.
Elle peut par exemple les ordonner en fonction des dates auxquelles elles ont été insérées, en fonction des pairs qui les ont insérées, ou tout autres caractéristiques qui les différencient.
Ce choix semble arbitraire et difficile à justifier.
Il conduit à de nombreuses spécifications pour les séquences répliquées.
D'un point de vue abstrait, il y a peu d'intérêt de s'intéresser à des spécifications complètes.
C'est pourquoi, la littérature présente des spécifications partielles qui se contente de spécifier un ordre partiel entre les valeurs et de définir la séquence comme une extension linéaire de cet ordre partiel.
Une spécification complète devient alors un raffinement d'une spécification partielle qui choisit une linéarisation de l'ordre partiel.
La littérature présente trois spécifications partielles~:

\paragraph{La spécification faible}\autocite{attiyai_2016_spec-text-editing} ne prend pas en compte les valeurs supprimées dans l'ordre partiel entre les valeurs.
Dans l'exécution abstraite de la \autoref{fig:replseq-sematic-1}, si nous ne prenons pas en compte la valeur supprimée $\textsf{'\textit{y}'}$, alors $p_A$ insère la chaîne $\textsf{'\textit{ies}'}$ entre $\textsf{'\textit{d}'}$ et la fin de la séquence.
De même, $p_B$ insère $\textsf{'\textit{\negthinspace!}'}$ entre $\textsf{'\textit{d}'}$ et la fin de la séquence.
Nous obtenons ainsi l'ordre partiel illustré dans la \autoref{fig:replseq-sematic-2}.
Cet ordre admet 4 extensions linéaires.
Le protocole de réplication utilisée par \emph{Google Docs} respecte la spécification faible~\autocite{wei2018_jupiterweak}.

\paragraph{La spécification forte}\autocite{attiyai_2016_spec-text-editing} prend en  compte l'ordre partiel entre toutes les valeurs, y compris les valeurs supprimées.
Dans l'exécution abstraite de la \autoref{fig:replseq-sematic-1}, si nous prenons en compte la valeur supprimée $\textsf{'\textit{y}'}$, alors $p_A$ insère $\textsf{'\textit{i}'}$ entre $\textsf{'\textit{d}'}$ et $\textsf{'\textit{y}'}$.
Il insère également la chaîne $\textsf{'\textit{es}'}$ entre $\textsf{'\textit{y}'}$ et la fin de la séquence.
$p_B$ insère $\textsf{'\textit{\negthinspace!}'}$ entre $\textsf{'\textit{y}'}$ et la fin de la séquence.
Nous obtenons ainsi l'ordre partiel illustré dans la \autoref{fig:replseq-sematic-3}.
Cet ordre admet 3 extensions linéaires.

\paragraph{La spécification forte sans entrelacement}\autocite{kleppmann2019_interleaving,kleppmann2018opsets} évite les entrelacements de n-uplet de valeurs insérés en parallèle.
Dans l'exécution abstraite de la \autoref{fig:replseq-sematic-1}, la chaîne $\textsf{'\textit{es}'}$ est insérée en parallèle du caractère $\textsf{'\textit{\negthinspace!}'}$.
La spécification forte sans entrelacement produit le même ordre partiel que la spécification forte, mais elle rejette l'extension linéaire qui produit un entrelacement, c'est-à-dire la chaîne $\textit{ladie\textit{\negthinspace!}s}$.
Le caractère $\textsf{'\textit{\negthinspace!}'}$ apparaît nécessairement avant ou après la chaîne $\textsf{'\textit{es}'}$.

\begin{figure}[htb]
\newcommand\hsep{1.2}
\newcommand\vsep{-1.2}
\centering
\begin{subfigure}{\linewidth}
    \centering
    \begin{tikzpicture}
        % Peers
        \path node (A) {$p_A$}
            to +(0,\vsep) node (B) {$p_B$}
        ;
        % Timeline ends
        \path (12*\hsep,0) coordinate (aend)
            to +(0,\vsep) coordinate (bend)
        ;
        % Events
        \path (A)
            to +(2*\hsep,0) node[
                label={above:$\trm{ins}(0, \textit{lady})$}
            ] (a1) {$a_1$}
            to +(4*\hsep,0) node[
                label={above:$\trm{ins}(3, \textsf{'\textit{i}'})$}
            ] (a5) {$a_2$}
            to +(6*\hsep,0) node[
                label={above:$\trm{del}(4)$}
            ] (a6) {$a_3$}
            to +(8*\hsep,0) node[
                label={above:$\trm{ins}(4, \textit{es})$}
            ] (a7) {$a_4$}
            to +(10*\hsep,0) node[
                label={above:$\trm{rd} \textit{ladies}$}
            ] (a9) {$a_6$}
        ;
        \path (B)
            to +(3*\hsep,0) node[
                label={below:$\trm{ins}(4, \textsf{'\textit{!}'})$}
            ] (b1) {$b_1$}
            to +(5*\hsep,0) node[
                label={below:$\trm{rd} \textit{lady\textbf{!}}$}
            ] (b2) {$b_2$}
            to +(11*\hsep,0) node[
                label={below:$\trm{rd} ?$}
            ] (b3) {$b_{3}$}
        ;
        % Timelines
        \foreach \src/\dest in {A/a1,a9/aend,B/b1,b3/bend}
            \draw (\src) edge[timeline] (\dest);
        % Precdence
        \foreach \src/\dest in {a1/a5,a5/a6,a6/a7,a7/a9,b1/b2,b2/b3}
            \draw[pre] (\src) to (\dest);
        \foreach \src/\dest in {a1/b1,a9/b3}
            \draw[pre] (\src) to (\dest);
    \end{tikzpicture}
    \caption{}\label{fig:replseq-sematic-1}
\end{subfigure}
\par\medskip
\begin{subfigure}{0.49\linewidth}
    \centering
    \begin{tikzpicture}
        \node (c) at (0,0) {$l$};
        \node (i) at (1,0) {$a$};
        \node (t) at (2,0) {$d$};
        \node (!) at (3,-0.5) {$!$};
        \node (i2) at (3,0.5) {$i$};
        \node (e) at (4,0.5) {$e$};
        \node (s) at (5,0.5) {$s$};
        \draw (c) to (i);
        \draw (i) to (t);
        \draw (t) to (!);
        \draw (t) to (i2);
        \draw (i2) to (e);
        \draw (e) to (s);
    \end{tikzpicture}
    \caption{}\label{fig:replseq-sematic-2}
\end{subfigure}
\begin{subfigure}{0.49\linewidth}
    \centering
    \begin{tikzpicture}
        \node (c) at (0,0) {$l$};
        \node (i) at (1,0) {$a$};
        \node (t) at (2,0) {$d$};
        \node (i2) at (3,0) {$i$};
        \node[draw] (y) at (4,-0.5) {$y$};
        \node (!) at (5,-0.5) {$!$};
        \node (e) at (4,0.5) {$e$};
        \node (s) at (5,0.5) {$s$};
        \draw (c) to (i);
        \draw (i) to (t);
        \draw (t) to (i2);
        \draw (i2) to (y);
        \draw (y) to (!);
        \draw (i2) to (e);
        \draw (e) to (s);
    \end{tikzpicture}
    \caption{}\label{fig:replseq-sematic-3}
\end{subfigure}
\par\medskip
\begin{subfigure}{\linewidth}
    \centering
    \begin{tabular}{cccc}
        $\trm{rval}(b_3)$ & Spéc.\ faible & Spéc.\ forte & Spéc.\ forte sans entrelacement\\
        \toprule
        $\textit{ladies\textbf{\textit{\negthinspace!}}}$ & \checkmark{} & \checkmark{} & \checkmark{} \\
        $\textit{ladi\textbf{\textit{\negthinspace!}}es}$ & \checkmark{} & \checkmark{} & \checkmark{} \\
        $\textit{ladie\textbf{\textit{\negthinspace!}}s}$ & \checkmark{} & \checkmark{} & \\
        $\textit{lad\textbf{\textit{\negthinspace!}}ies}$ & \checkmark{}& & \\
    \end{tabular}
    \caption{}\label{fig:replseq-sematic-4}
\end{subfigure}
\caption[Illustration des différentes spécifications partielles d'une séquence répliquée]{Illustration des différentes spécifications partielles d'une séquence répliquée.
\subref{fig:replseq-sematic-1} L'exécution abstraite considérée respecte le modèle de cohérence causale.
\subref{fig:replseq-sematic-4} Les valeurs de retour admises de l'opération de lecture $b_3$ dépendent de la spécification choisit.
Elles correspondent à des extensions linéaires des ordres partiels induits par la spécification faible \subref{fig:replseq-sematic-2} ou la spécification forte \subref{fig:replseq-sematic-3}.}\label{fig:replseq-sematic}
\end{figure}

%\paragraph{} \textcite{attiyai_2016_spec-text-editing} ont montré que le protocole de réplication optimiste de séquence \emph{RGA} respecte la spécification forte.
%Ce dernier présente une adaptation~\autocite{kleppmann2019_interleaving} pour respecter la spécification forte sans entrelacement.
%Bien que ce ne soit pas prouvé, les protocoles de réplication optimiste de séquences présentés dans cet état de l'art respectent la spécification forte.

Pour respecter une spécification, les protocoles de réplication optimiste proposés dans la littérature mettent en oeuvre différents stratégies.
Dans ce manuscrit nous nous intéressons particulièrement aux \acp{CRDT}.
Un \ac{CRDT} encapsule le protocole de réplication optimiste derrière une interface familière.
Dans le cas d'une séquence répliquée, l'utilisateur·ice modifie la séquence et la lit de la même manière qu'il ou elle le ferait avec une séquence classique.
Le protocole se charge d'exécuter les opérations et de synchroniser la copie de la séquence partagée avec les autres copies de la séquence.

%Les \acp{CRDT} séquences attachent à chaque élément des méta-données qui permettent de former l'ordre de la séquence.
%Ces méta-données sont générés de telle manière à garantir l'intention d'une insertion et d'une suppression.
%Nous distinguons deux approches qui reposent sur des principes de générations distincts de ces méta-données.
%
%\paragraph{L'approche à pierres tombales}\autocite{oster_2006_woot, roh_2011_rga} identifie chaque valeur avec un identifiant unique et immuable.
%Une valeur référence une des valeurs entre lesquelles elle est insérée ou éventuellement les deux.
%D'autres méta-données peuvent être ajoutés pour déterminer l'ordre total des valeurs de la séquence.
%Cette approche se caractérise généralement par une complexité spatiale constante des méta-données associées aux valeurs.
%Cependant, une valeur ne peut être insérée avant l'insertion des valeurs qu'elle référence.
%Cette approche est généralement synchronisée par opérations et emploie une livraison causale des opérations.
%Elle requiert également la conservation des valeurs supprimées pour permettre l'insertion des valeurs qui les référencent.
%Pour ne pas apparaître lors des lectures, ces valeurs sont marquées et deviennent des \emph{pierres tombales}.
%Parce qu'elles sont conservées au sein de la séquence répliquée, les pierres tombales réduisent les performances générales de la séquence répliquée lorsque le nombre de suppressions est important.
%
%\paragraph{L'approche à positions densément ordonnées}\autocite{weiss_2009_logoot, preguica_2009_treedoc, nedelec_2013_lseq} associe à chaque valeur une position unique et immuable.
%L'ensemble des positions est densément et totalement ordonné.
%Lorsqu'une valeur est insérée entre deux autres valeurs, sa position est générée de telle sorte à ce qu'elle soit comprise entre les positions de ces deux dernières.
%Les positions sont indépendantes~: une valeur peut être insérée même si les valeurs entre lesquelles elle a été initialement inséré sont absentes.
%Une valeur et sa position peuvent donc être définitivement supprimée.
%Cependant, pour encoder un ordre dense, les positions n'ont pas une taille constante.
%Au fur et à mesure de la collaboration, la taille des positions croît.
%Ce qui réduit les performances de la séquence répliquée.
%
%\paragraph{} Les \acp{CRDT} des deux approches tentent de minimiser la taille des méta-données associées à chaque valeur.
%Chaque approche a connu des raffinements qui ont conduit à des séquence à granularité variable.
%Les valeurs sont groupées en blocs et les méta-données sont attachées aux blocs au lieu d'être attachées individuellement aux valeurs.
%
%
%
%Les deux familles de séquences répliquées réduisent toutes deux leur occupation mémoire en adoptant une approche à granularité variable~\cite{yu_2012_string-wise-crdt, andre_2013_logootsplit, briot_2016_rgasplit}.
%Les valeurs sont groupées en blocs et leurs identifiants sont agrégés.
%La réduction est particulièrement notable lorsque les séquences sont utilisées pour l'édition collaborative~\autocite{andre_2013_logootsplit,briot_2016_rgasplit}.


%Pour certains \acp{CRDT}, ces méta-données croient de manière supra-linéaire par rapport à la taille d'une structure de données non-répliquées [REF].
%
%Les séquences répliquées permettent l'implémentation d'éditeurs collaboratifs.
%Dans ce type d'applications elles peuvent être soumises à des sessions de collaboration intensive qui réunissent un nombre important de rédacteur·ice·s.
%Ce qui conduit à un accroissement rapide des méta-données nécessaires au support de l'édition collaborative.
%Les éditeurs collaboratifs sont souvent utilisés au sein de navigateurs web~\autocite{mohan_2010_realtimegroupware} qui contraint à la fois leur usage de mémoire volatile et de mémoire persistante.
%De ce fait, les séquences répliquées, appliquées aux éditeurs collaboratifs, doivent à la fois être réactives et minimiser leur occupation mémoire.
%

% RÉFLEXION SPÉCIFICATION
%
% Pour pouvoir spécifier la séquence et la faire correspondre à  la strong sepc
% nous devrions ajouter un paramètre aux insertion et suppression.
% Ce paramètre correspond à un id unique de valeur.
% On map ainsi directement à la strong sepc avec quelques axiomes en plus tel que:
% - la suppression du n-ème caractère correspond bien en terme d'id.
%
% Ou au lieu de l'id unique sur le char on pourrait se contenter d'ajouter un
% paramètre à la suppression qui correspond à l'opération d'insertion du
% caractère supprimé.

\subsection{Séquences répliquées de la littérature}

Plusieurs \acp{CRDT} séquences sont proposés dans la littérature.
Un \ac{CRDT} séquence peut exécuter une opération d'insertion, une opération de suppression, et une opération de lecture.
L'exécution d'une opération d'insertion ou d'une opération de suppression génère un message.
Le message est intégré à la copie de la séquence avant d'être transmis aux autres pairs qui l'intègrent à terme à leur copie.
Nous détaillons chacune de ses procédures pour chacun des \acp{CRDT} que nous présentons.
Nous caractérisons également la structure du \ac{CRDT} et des messages qu'il génère.

\paragraph{WOOT}\autocite{oster_2006_woot} est le premier \ac{CRDT} Séquence présenté dans la littérature.
Plusieurs optimisations de \emph{WOOT}~\autocite{weiss2007wooki,ahmednacer2011evaluatingcrdts} ont été proposées.
Il prend à la lettre la formulation de l'intention d'une insertion~: une valeur référence les deux valeurs entre lesquelles elle est insérée.

\emph{WOOT} référence les valeurs à l'aide de leurs identifiants.
L'identifiant d'une valeur est constitué par l'identifiant du pair qui l'a inséré et un nombre séquentiel.
Chaque pair maintient son propre nombre séquentiel qu'il incrémente avant chaque exécution d'une opération d'insertion.
Ce nombre correspond donc au nombre de valeurs insérés par le pair.
Si $v$ est la n-ème valeur insérée par le pair $p_i$ elle est associée à l'identifiant $\tuple*{p_i, n}$.
Deux identifiants sont réservés pour identifier le début et la fin de la séquence.

Les identifiants des valeurs sont également utilisés pour détermine l'ordre entre deux valeurs insérées en parallèle au même emplacement.
L'algorithme de placement de valeurs est détaillé ci-après.
Il se base sur un ordre lexicographique entre les identifiants des valeurs et un ordre total entre les identifiants des pairs.
Un identifiant $\tuple*{p_i, n}$ est supérieur à un identifiant $\tuple*{p_j, m}$ si et seulement si $p_i$ est supérieur à $p_j$ ou si $p_i$ est égal à $p_j$ et $n$ est supérieur à $m$.

Une séquence \emph{WOOT} est une liste des valeurs insérées auxquelles sont associées des méta-données.
Les méta-données d'une valeur incluent l'identifiant de la valeur, et les identifiants des valeurs entre lesquelles elle a été initialement insérée.

Lorsqu'un pair exécute une opération d'insertion de la valeur $v$ avant la $n$-ème valeur, il procède en plusieurs étapes.
Il génère d'abord un nouvel identifiant pour $v$ et récupère les identifiants de la $n-1$-ème valeur et de la $n$-ème valeur.
Il s'agit des valeurs entre lesquelles la valeur doit être insérée.
Le pair génère alors un message d'insertion qui contient la valeur, l'identifiant de la valeur, et les identifiants des valeurs entre lesquelles la valeur doit être insérée.
Le message est intégré à la copie de la séquence et est transmis aux autres pairs.

L'intégration d'un message d'insertion d'une valeur $v$ se déroule comme suit.
Le message contient les identifiants des valeurs $v_1$ et $v_2$ entre lesquelles $v$ doit être insérée.
Ces deux valeurs sont récupérés.
Des valeurs peuvent être présentes entre $v_1$ et $v_2$.
Il s'agit de valeurs insérées en parallêle de $v$.
Pour déterminer où placer $v$, le pair applique l'algorithme récursif suivant.
Il récupère l'ensemble des valeurs comprises entre $v_1$ et $v_2$.
Si l'ensemble est vide, alors la valeur est simplement placée entre $v_1$ et $v_2$.
Dans le cas contraire, il récupère le sous-ensemble des valeurs qui référencent des valeurs qui ne sont pas comprises entre $v_1$ et $v_2$.
Ces valeurs ont été insérées en parallèle de $v_1$ et $v_2$.
L'emplacement relatif de $v$ par rapport à ces dernières est déterminé à l'aide de l'ordre lexicographique entre leurs identifiants.
L'algorithme est répété en considérant les deux valeurs entre lesquelles $v$ doit être placé comme les valeurs $v_1$ et $v_2$.

Pour illustrer cet algorithme, nous reprenons l'exemple de la \autoref{fig:replseq-sematic-1}.
Une fois l'ensemble des modifications intégrées, la séquence \emph{WOOT} de la \autoref{fig:woot} est obtenue.
Un identifiant $\tuple*{p_i, n}$ est noté $i_n$.
$p_B$ intègre les messages d'insertion générés par l'exécution des opérations $a_2$, $a_3$, et $a_4$ avant d'exécuter l'opération de lecture $b_3$.
$p_B$ débute avec la séquence $\textsf{'\textit{lady\negthinspace!}'}$.
Le caractère $\textsf{'\textit{i}'}$ référence les caractères $\textsf{'\textit{d}'}$ et $\textsf{'\textit{y}'}$.
Aucun caractère n'est déjà présent entre ces deux caractères.
$\textsf{'\textit{i}'}$ est donc simplement placé entre eux.
$p_B$ obtient la séquence $\textsf{'\textit{ladiy\negthinspace!}'}$.
Il intègre ensuite la suppression du caractère $\textsf{'\textit{y}'}$.
Le caractère $\textsf{'\textit{e}'}$ référence le $\textsf{'\textit{i}'}$ et la fin de la séquence.
Or il existe un ensemble de caractères entre $\textsf{'\textit{i}'}$ et la fin de la séquence.
Nous devons déterminer l'ordre entre $\textsf{'\textit{e}'}$ et ces caractères.
Cet ensemble corresponds à la pierre tombale $\textsf{'\textit{y}'}$ et au caractère $\textsf{'\textit{\negthinspace!}'}$.
Seul $\textsf{'\textit{y}'}$ référence des valeurs qui ne sont pas comprises entre les valeurs référencées par $\textsf{'\textit{e}'}$.
L'identifiant de $\textsf{'\textit{y}'}$ est plus petit que l'identifiant de $\textsf{'\textit{e}'}$ ($A_4 < A_6$).
$\textsf{'\textit{e}'}$ doit donc être placé entre cette pierre tombale et la fin de la séquence.
Or $\textsf{'\textit{\negthinspace!}'}$ est entre ces deux bornes.
L'identifiant de $\textsf{'\textit{e}'}$ est plus petit que l'identifiant de $\textsf{'\textit{\negthinspace!}'}$ ($A_6 < B_1$), il est donc placé avant.
En répétant l'algorithme pour le caractère $\textsf{'\textit{s}'}$, on en déduit que $\textsf{'\textit{s}'}$ est placé entre $\textsf{'\textit{e}'}$ et $\textsf{'\textit{\negthinspace!}'}$.


\begin{figure}[tb]
\centering
\begin{subfigure}[b]{0.49\linewidth}
    \centering
    \begin{tikzpicture}
        \node[letter,
                label={below:$A_1$}
            ] {$l$}
        to ++(\widthletter,0) node[letter,
                label={below:$A_2$}
            ]{$a$}
        to ++(\widthletter,0) node[letter,
                label={below:$A_3$}
            ]{$d$}
        to ++(\widthletter,0) node[letter,
                label={below:$A_5$}
            ]{$i$}
        to ++(\widthletter,0) node[letter,crossed,
                label={below:$A_4$}
            ]{$y$}
        to ++(\widthletter,0) node[letter,
                label={below:$A_6$}
            ]{$e$}
        to ++(\widthletter,0) node[letter,
                label={below:$A_7$}
            ]{$s$}
        to ++(\widthletter,0) node[letter,
                label={below:$B_1$}
            ]{$\negthinspace!$}
        ;
    \end{tikzpicture}
    \caption{}\label{fig:woot-1}
\end{subfigure}
\begin{subfigure}[b]{0.49\linewidth}
    \centering
    \begin{tikzpicture}
        \newcommand\hsep{0.6}
        \node(c) at (\hsep,0) {$l$};
        \node(i) at (3*\hsep,0) {$a$};
        \node(t) at (5*\hsep,0) {$d$};
        \node(i2) at (6*\hsep,-1) {$i$};
        \node[crossed](y) at (7*\hsep,0) {$y$};
        \node(e) at (8*\hsep,-1) {$e$};
        \node(s) at (10*\hsep,-1) {$s$};
        \node(!) at (11*\hsep,0) {\negthinspace!};
        \draw[-latex] (i) to (c);
        \draw[-latex] (t) to (i);
        \draw[-latex] (y) to (t);
        \draw[-latex] (!) to (y);
        \draw[-latex] (i2) to (t);
        \draw[-latex] (i2) to (y);
        \draw[-latex] (i2) to (y);
        \draw[-latex] (e) to (i2);
        \draw[-latex] (s) to (e);
    \end{tikzpicture}
    \caption{}\label{fig:woot-2}
\end{subfigure}
\caption[Exemple d'une séquence \emph{WOOT}]{Exemple d'une séquence \emph{WOOT}.
\subref{fig:woot-1} Séquence de valeurs et pierres tombales associées à leurs identifiants.
Les pierres tombales sont représentées par un caractère barré.
\subref{fig:woot-2} Valeurs référencés par les valeurs de la séquence.
    Les références vers le début et la fin de la séquence sont omises.}\label{fig:woot}
\end{figure}

Lorsqu'un pair exécute une opération de suppression il détermine d'abord l'identifiant de la valeur à supprimer.
Il génère alors un message de suppression qui contient seulement cet identifiant.
Ce message est intégré à la copie de la séquence et est transmis aux autres pairs.

L'intégration d'un message de suppression est relativement simple.
L'identifiant de la valeur à supprimer est récupérée du message.
Une valeur ne peut pas être définitivement supprimée étant donné que d'autres valeurs sont susceptibles de la référencer.
La valeur est donc remplacée par une pierre tombale.
Les méta-données associées à la valeur sont conservées.
Elles sont associées à la pierre tombale qui lui fait place.

L'exécution d'une opération de lecture renvoie la séquence des valeurs sans les pierres tombales.
La conservation des valeurs supprimées sous forme de pierres tombales fait croître la séquence de manière monotone.
Cette croissance réduit l'efficacité de l'exécution des opérations et de l'intégration des messages.

\emph{WOOT} repose sur une synchronisation par opérations.
Les messages doivent être livrés exactement une fois et dans un ordre spécifique.
Un message de suppression doit être livré après le message qui insère la valeur  à supprimer.
Pour insérer une valeur, les valeurs qu'elle référencent doivent être déjà présentes dans la séquence.
Un message d'insertion doit donc être livré après les messages d'insertion des valeurs référencées.


\paragraph{\acf{RGA}}\autocite{roh_2011_rga} améliore l'approche proposée par \emph{WOOT}.
Une valeur référence uniquement la valeur qui la précède dans la séquence.
Deux valeurs qui référencent la même valeur sont ordonnées entre elles à l'aide de leurs identifiants respectifs.

L'identifiant d'une valeur est formé d'un horodatage et de l'identifiant du pair.
L'horodatage est produit à l'aide d'une horloge de \emph{Lamport}~\autocite{lamport_1978_time}.
L'identifiant associé a une nouvelle valeur est donc toujours supérieur à l'horodatage de l'ensemble des valeurs et pierres tombales déjà présentes dans la copie de la séquence.

L'ordre entre deux valeurs qui référencent la même valeur est déterminé par un ordre lexicographique entre leurs identifiants et un ordre total entre les identifiants des pairs.
Un identifiant $\tuple*{n,p_i}$ est supérieur à un identifiant $\tuple*{m,p_j}$ si et seulement si l'horodatage $n$ est supérieur à l'horodatage $m$ ou si $n$ est égal à $m$ et l'identifiant du pair $p_i$ est supérieur à l'identifiant du pair $p_j$.

Une séquence \emph{RGA} est une liste de valeurs auxquelles sont associées leur identifiant.
Contrairement à \emph{WOOT}, la séquence n'a pas besoin de retenir les références entre les valeurs.
Cette caractéristique résulte d'un algorithme de placement des valeurs plus simple.

Lorsqu'un pair exécute une opération d'insertion de la valeur $v$ avant la $n$-ème valeur de la séquence, il génère un message d'insertion.
Le message d'insertion contient la valeur, l'identifiant de la valeur, et l'identifiant de la $n-1$-ème valeur.
La $n-1$-ème valeur correspond à la valeur après laquelle $v$ doit être inséré.
Par la suite nous constaterons que les identifiants de $v$ et de la $n$-ème valeur conduisent nécessairement à placer $v$ avant la $n$-ème valeur.
L'intention d'insérer $v$ entre la $n-1$-ème valeur et la $n$-ème valeur est donc respectée à la fois par le référence à la $n-1$-ème valeur et par le choix des identifiants associées aux valeurs.
Le message est intégré à la copie de la séquence et est propagé aux autres pairs.

L'intégration d'un message d'insertion d'une valeur $v$ se déroule comme suit.
L'identifiant de la valeur $v_1$ après laquelle $v$ doit être inséré est récupéré à partir du message.
Pour déterminer l'emplacement de $v$, le pair applique l'algorithme récursif suivant.
Si il n'y a aucune valeur après $v_1$, alors $v$ y est simplement placé.
Sinon l'identifiant de $v$ est comparé à l'identifiant de la valeur $v_2$ qui se situe juste après $v_1$.
Si l'identifiant de $v$ est supérieur à l'identifiant de $v_2$, alors $v$ est placé entre $v_1$ et $v_2$.
Dans le cas contraire, $v$ doit être inséré après $v_2$.
L'algorithme est donc répété en considérant $v_2$ comme $v_1$.

Pour illustrer cet algorithme, nous reprenons l'exemple de la \autoref{fig:replseq-sematic-1}.
Une fois l'ensemble des modifications intégrées, la séquence \emph{RGA} de la \autoref{fig:rga} est obtenue.
Un identifiant $\tuple*{n, p_i}$ est noté $n_i$.
$p_B$ débute avec la séquence $\textsf{'\textit{lady}'}$.
Il insère le caractère $\textsf{'\textit{\negthinspace!}'}$ entre $\textsf{'\textit{y}'}$ et la fin de la séquence.
Il génère un identifiant dont l'horodatage est supérieur a ceux déjà générés dans la séquence.
Il génère donc un horodatage égale à $5$.
L'intégration de cette insertion s'effectue simplement en plaçant le caractère après $\textsf{'\textit{y}'}$.
Il intègre ensuite l'insertion du caractère $\textsf{'\textit{i}'}$ qui référence le caractère $\textsf{'\textit{d}'}$.
Les caractères $\textsf{'\textit{y}'}$ et $\textsf{'\textit{\negthinspace!}'}$ se situent déjà après $\textsf{'\textit{d}'}$.
L'identifiant de $\textsf{'\textit{i}'}$ est supérieur à l'identifiant de $\textsf{'\textit{y}'}$ ($5_A > 4_A$).
$\textsf{'\textit{i}'}$ est donc placé avant $\textsf{'\textit{y}'}$.
Il intègre de la même manière les insertions des caractères $\textsf{'\textit{e}'}$ et $\textsf{'\textit{s}'}$.


\begin{figure}[tb]
\centering
\begin{subfigure}[b]{0.49\linewidth}
    \centering
    \begin{tikzpicture}
        \node[letter,
                label={below:$1_A$}
            ] {$l$}
        to ++(\widthletter,0) node[letter,
                label={below:$2_A$}
            ]{$a$}
        to ++(\widthletter,0) node[letter,
                label={below:$3_A$}
            ]{$d$}
        to ++(\widthletter,0) node[letter,
                label={below:$5_A$}
            ]{$i$}
        to ++(\widthletter,0) node[letter,
                label={below:$6_A$}
            ]{$e$}
        to ++(\widthletter,0) node[letter,
                label={below:$7_A$}
            ]{$s$}
        to ++(\widthletter,0) node[letter,crossed,
                label={below:$4_A$}
            ]{$y$}
        to ++(\widthletter,0) node[letter,
                label={below:$5_B$}
            ]{$\negthinspace!$}
        ;
    \end{tikzpicture}
    \caption{}\label{fig:rga-1}
\end{subfigure}
\begin{subfigure}[b]{0.49\linewidth}
    \centering
    \begin{tikzpicture}
        \newcommand\hsep{0.6}
        \node(c) at (\hsep,0) {$l$};
        \node(i) at (3*\hsep,0) {$a$};
        \node(t) at (5*\hsep,0) {$d$};
        \node(i2) at (6*\hsep,-1) {$i$};
        \node(e) at (8*\hsep,-1) {$e$};
        \node(s) at (10*\hsep,-1) {$s$};
        \node[crossed](y) at (11*\hsep,0) {$y$};
        \node(!) at (13*\hsep,0) {\negthinspace!};
        \draw[-latex] (i) to (c);
        \draw[-latex] (t) to (i);
        \draw[-latex] (y) to (t);
        \draw[-latex] (!) to (y);
        \draw[-latex] (i2) to (t);
        \draw[-latex] (e) to (i2);
        \draw[-latex] (s) to (e);
    \end{tikzpicture}
    \caption{}\label{fig:rga-2}
\end{subfigure}
\caption[Exemple d'une séquence \emph{RGA}]{Exemple d'une séquence \emph{RGA}.
\subref{fig:rga-1} Séquence de valeurs et pierres tombales associées à leurs identifiants.
Les pierres tombales sont représentées par un caractère barré.
\subref{fig:rga-2} Valeurs référencés par les valeurs de la séquence.
Les références vers le début de la séquence sont omises.}\label{fig:rga}
\end{figure}

La suppression d'une valeur et la lecture d'une séquence suivent les mêmes logiques que celles présentées pour \emph{WOOT}.
Une séquence \emph{RGA} croît donc de manière monotone.

\emph{RGA} utilise deux structures de données pour son implémentation~: une liste chaînée et une table de hachage.
La liste chaînée contient les valeurs et des pierres tombales ainsi que leurs identifiants.
La table de hachage fait correspondre à un identifiant le chaînon de la liste chaînée qui inclut la valeur ou la pierre tombale qu'il identifie.

\emph{RGA} repose sur une synchronisation par opérations.
Les messages doivent être livrés exactement une fois.
Les messages de suppression doivent être livrés après l'intégration du message d'insertion de la valeur à supprimer.
Pour insérer une valeur, la valeur référencée doit déjà être présente dans la séquence.
Un message d'insertion doit donc être intégré après l'intégration du message d'insertion de la valeur référencée.
La suppression d'une référence comparé à \emph{WOOT} permet de réduire le risque de bloquer une insertion dans l'attente que les valeurs qu'elle référence soient insérées.

\emph{RGA} respecte la spécification forte~\autocite{attiyai_2016_spec-text-editing}.
Une extension~\autocite{kleppmann2019_interleaving} permet à \emph{RGA} de rejeter tout entrelacement.
Pour ce faire, un ensemble d'identifiants est associé à chaque valeur.
Ils correspondent aux identifiants des valeurs qui référencent une même valeur au moment de l'insertion de la nouvelle valeur.
Dans la \autoref{fig:rga}, les valeurs, à l'exception de $\textsf{'\textit{i}'}$ sont associées à un ensemble vide.
Au moment de l'insertion du caractère $\textsf{'\textit{i}'}$, le caractère $\textsf{'\textit{y}'}$ référence déjà le caractère $\textsf{'\textit{d}'}$.
$\textsf{'\textit{i}'}$ inclus donc l'identifiant de $\textsf{'\textit{y}'}$ dans l'ensemble qui lui est associé.
L'intégration d'une insertion prend en compte cette ensemble pour déterminer l'ordre entre les valeurs.
L'ajout de cet ensemble augmente l'occupation mémoire de la structure et à un coût en communication puisqu'il fait partie des messages d'insertion.
En pratique, la taille de ces ensembles est attendue à être faible~\autocite{kleppmann2019_interleaving}.


%\paragraph{Yata}\autocite{nicolaescu2015yjs} emprunte des idées de \emph{WOOT} et \emph{RGA}.


\paragraph{Logoot}\autocite{weiss_2009_logoot} prend une approche distincte de \emph{WOOT} et \emph{RGA}.
Une valeur ne référence pas d'autres valeurs.
Une valeur peut donc être placée sans la présence des valeurs entre lesquelles elle a été insérée.
Pour ce faire, chaque valeur est associée à une position unique et immuable.
L'ordre entre les valeurs de la séquence est construit à partir de l'ordre total entre les positions.
Lorsqu'une nouvelle valeur est insérée entre deux valeurs, sa position est générée de telle sorte à ce qu'elle soit comprise entre les positions de ces deux valeurs.

Une valeur peut toujours être insérée entre deux autres valeurs.
L'ordre entre les positions est donc dense.
\emph{Logoot} génère un ordre total et dense à l'aide d'un ordre lexicographique entre des listes d'éléments.
Par exemple l'ordre lexicographique des chaînes de caractères est un ordre total et dense.
La chaîne $\textsf{ab}$ est inférieure à la chaîne $\textsf{ac}$ et la chaîne $\textsf{abx}$ est comprises entre elles.
Une nouvelle position est donc obtenue en recopiant éventuellement des éléments des positions voisines et en générant un nouvel élément.
Dans le cas de la chaîne $\textsf{abx}$, les éléments $\textsf{a}$ et $\textsf{b}$ sont recopiés et $\textsf{x}$ a été généré.
Deux pairs peuvent insérer une valeurs au même endroit.
Pour assurer que des insertions parallèles ne génèrent pas les mêmes positions, deux pairs ne doivent pas générer le même élément.
Pour s'en assurer \emph{Logoot} utilise comme éléments des couples formés par un entier et l'identifiant du pair qui a généré le couple.
Finalement pour éviter qu'un pair génère deux positions identiques, un nombre séquentiel est adjoint à la liste de couples.
Chaque pair incrémente son propre nombre séquentiel après chaque exécution d'une opération d'insertion.
Le nombre séquentiel est donc consommé par la génération d'une nouvelle position.
Les positions \emph{Logoot} présenté dans des travaux ultérieurs~\autocite{weiss2010logoot} sont légèrement différentes.
La position devient une liste de triplets constitué d'un entier aléatoire, de l'identifiant et du nombre séquentiel du pair qui a généré le triplet.

Deux positions sont comparées de manière lexicographique.
Une position $p_1$ est supérieure à une position $p_2$ si et seulement si \begin{inlinelist}\item leur liste de couples sont identiques et le nombre séquentiel de $p_1$ est supérieur à celui de $p_2$, ou si \item la liste de couples de $p_1$ est un préfixe de la liste de couples de $p_2$, ou si \item les listes de $p_1$ et $p_2$ ont un préfixe commun de $n-1$ couples tel que le $n$-ème couple de $p_1$ est lexicographqiquement supérieur au $n$-ème couple de $p_2$.\end{inlinelist}

Une séquence \emph{Logoot} est simplement une liste des valeurs auxquelles sont associées leurs positions.
L'exécution d'une opération d'insertion d'une valeur $v$ produit un message d'insertion composé de la valeur et de sa position.
Pour générer sa position, les positions $p_1$ et $p_2$ des valeurs entre lesquelles $v$ doit être insérée sont récupérées.
La position de $v$ doit être comprises entre ces deux positions.
Le nombre séquentiel est déjà connu, il suffit de générer la liste de la nouvelle position.
Pour simplifier l'explication nous considérons que les positions $p_1$ et $p_2$ ont des listes de taille infinie.
Ces listes de taille infinie sont obtenues en ajoutant des couples minimaux à $p_1$ et des couples maximaux à $p_2$.
$p_1$ reste donc inférieur à $p_2$.
La liste de la nouvelle position partage un préfixe commun de $n$ couples ($n \geq 0$) avec la liste de $p_1$ tel qu'il ne soit pas possible de choisir un entier compris entre les entiers du $k$-ème couple de $p_1$ et du $k$-ème couple de $p_2$ avec $k \leq n$.
Un $n+1$-ème couple est ajouté à la liste.
Ce couple est généré par le pair qui insère $v$.
Son entier est choisit aléatoirement entre les entiers du $n+1$-ème couple de $p_1$ et du $n+1$-ème couple de $p_2$.
Le message est intégré à la copie et transmis aux autres pairs.

\begin{figure}[tb]
\centering
\begin{subfigure}[b]{0.69\linewidth}
    \centering
    \begin{tikzpicture}
        \node[letter,
                label={below:$f_A1$}
            ] {$l$}
        to ++(\widthletter,0) node[letter,
                label={below:$h_A2$}
            ]{$a$}
        to ++(\widthletter,0) node[letter,
                label={below:$l_A3$}
            ]{$d$}
        to ++(\widthletter,0) node[block,
                label={below:$l_A q_A5$}
            ]{$i$}
        to ++(\widthblock,0) node[letter,
                label={below:$p_A6$}
            ]{$e$}
        to ++(\widthletter,0) node[letter,
                label={below:$r_A7$}
            ]{$s$}
        to ++(\widthletter,0) node[letter,
                label={below:$t_B1$}
            ]{$\negthinspace!$}
        ;
    \end{tikzpicture}
    \caption{}\label{fig:logoot-1}
\end{subfigure}
\begin{subfigure}[b]{0.29\linewidth}
    \centering
    \begin{tikzpicture}
        \node[letter,
                label={below:$m_A4$}
            ]{$y$}
        ;
    \end{tikzpicture}
    \caption{}\label{fig:logoot-2}
\end{subfigure}
\caption[Exemple d'une séquence \emph{Logoot}]{Exemple d'une séquence \emph{Logoot}.
\subref{fig:logoot-1} Séquence de valeurs associées à leurs positions.
\subref{fig:logoot-2} Valeur supprimée associée à sa position.}\label{fig:logoot}
\end{figure}

Pour illustrer cette algorithme, nous reprenons l'exemple de la \autoref{fig:replseq-sematic-1}.
Une fois l'ensemble des insertions intégrées, la séquence \emph{Logoot} de la \autoref{fig:logoot-1} est obtenue.
Dans cette représentation un couple $\tuple*{2, p_A}$ est représenté par $b_A$ où $b$ est la deuxième lettre de l'alphabet latin.
Pour simplifier nous considérons donc que les entiers des couples sont compris entre $1$ et $26$.
Par exemple, la position $l_A q_A5$ a une liste de deux couples et un nombre séquentiel égal à $5$.
$p_A$ insère le caractère $\textsf{'\textit{i}'}$ entre les caractères $\textsf{'\textit{d}'}$ et $\textsf{'\textit{y}'}$.
Il doit donc générer une position entre les positions $l_A3$ et $m_A4$.
$l$ et $m$ sont contiguës.
Le couple $l_A$ est donc copié.
Le couple $q_A$ est généré.
Nous obtenons donc la liste $l_A q_A$ auquel est adjoint la valeur actuel du nombre séquentiel de $p_A$.
Puisqu'il s'agit de la cinquième insertion de $p_A$, son nombre séquentiel est égal à $5$.
Le caractère insérée est donc associé à la position $l_A q_{A5}$.
On constate un ordre total entre les positions des valeurs insérées~: $f_A1 < h_A2 < l_A3 < l_A q_A5 < m_A4 < p_A6 < r_A7 < t_B1$.

L'intégration d'un message d'insertion d'une valeur $v$ de position $p$ se déroule simplement par le placement de $v$ de telle manière à ce que les positions des valeurs qui précèdent $v$ dans la séquence soient inférieurs à $p$ et les positions des valeurs qui succèdent $v$ soient supérieurs à $p$.

L'exécution d'une opération de suppression produit un message de suppression qui contient la position de la valeur à supprimer.
L'intégration de ce message supprime définitivement la valeur associée à la position contenue dans le message.

\emph{Logoot} repose sur une synchronisation par opérations.
Les messages doivent être livrés exactement une fois.
Un message qui supprime la valeur de position $p$ est livré après le message qui insère la valeur de position $p$.
Les messages d'insertion peuvent être livrés dans un ordre arbitraire.

Par-ce-que les positions sont indépendantes les unes des autres, \emph{Logoot} n'a pas  besoin de pierres tombales.
Toutefois la taille des positions croît au fur et à mesure des insertions de valeurs dans la séquence.
Cette croissance de la taille des positions est particulièrement notable lorsque les insertions se concentrent dans une partie restreinte de la séquence.

\emph{Logoot} respecte la spécification forte.
Il souffre d'entrelacements~\autocite{kleppmann2019_interleaving}.


\paragraph{Treedoc}\autocite{preguica_2009_treedoc} repose sur la même idée que \emph{Logoot}~: placer les valeurs indépendamment des autres à l'aide de positions uniques et immuables.
Contrairement à \emph{Logoot}, \emph{Treedoc} pose des contraintes sur les structures de données utilisées afin d'éviter le stockage des positions.

Les valeurs sont rangées au sein d'un arbre binaire.
L'ordre de la séquence correspond à l'ordre infixe de l'arbre.
La position d'une valeur correspond au chemin qui doit être emprunté dans l'arbre pour l'atteindre.
Lorsqu'il n'y a pas d'insertions en parallèle, une position est donc simplement une liste de bits tel que $0$ indique de se diriger vers l'enfant gauche et $1$ indique de se diriger vers l'enfant droit.
L'ordre total et dense entre deux positions est formé par l'ordre lexicographique entre leur liste de bits.
Chaque insertion d'une nouvelle valeur créé un noeud situé à droite du noeud qui stocke la valeur qui la précède et à gauche du noeud de la valeur qui la succède.

L'insertion en parallèle de valeurs au même endroit conduit à la création de deux noeuds qui ont le même chemin dans l'arbre.
Pour remédier à ce problème, \emph{Treedoc} repose sur deux mécanismes~: l'identification des valeurs et le regroupement des noeuds ajoutés en concurrence en super-noeud.
Chaque valeur est identifiée par un \emph{dot} constitué de l'identifiant du pair qui a insérée la valeur et du nombre séquentiel du pair.
Un super-noeud est capable de stocker plusieurs valeurs.
Les valeurs des super-noeuds sont ordonnées selon l'ordre lexicographique de leurs \emph{dots}.
Chaque valeur d'un super-noeud est associée à un sous-arbre binaire.
Lorsqu'une valeur $v$ est insérée entre les valeurs $v_1$ et $v_2$ d'un super-noeud, $v$ est insérée dans le sous-arbre associé à $v_1$.
La position de $v$ indique son emplacement dans le sous-arbre de $v_1$ en utilisant l'identifiant de $v_1$.
Si la position de $v_1$ est $01$ et que son identifiant est $A_1$, alors $v$ a pour position $01A_1$.

L'exécution d'une opération d'insertion d'une valeur $v$ entre deux valeurs $v_1$ et $v_2$ produit un message d'intégration qui inclut la valeur, l'identifiant de la valeur, et la position de la valeur dans l'arbre.
La position est choisit de telle manière à ce qu'elle correspond au chemin vers le noeud qui stockera $v$ dans l'arbre.
Ce noeud est à droite de $v_1$ et à gauche de $v_2$.
L'intégration d'un message d'insertion s'effectue par la création d'un noeud dont le chemin correspond à la position de la valeur à insérer.
Si des noeuds et des super-noeuds sont manquants sur le chemin, ils sont créées.
Si le noeud où la valeur doit être stockée existe déjà, alors ce dernier est transformé en super-noeud.

L'exécution d'une opération de suppression de la $n$-ème valeur consiste à identifier l'emplacement de la valeur et à produire un message de suppression qui inclut l'identifiant de la valeur et sa position dans l'arbre.
L'intégration d'un message de suppression consiste à déterminer la valeur à supprimer à l'aide de sa position et de son identifiant et à la supprimer.
L'identifiant de la valeur permet de supprimer la bonne valeur lorsqu'elle se trouve dans un super-noeud.
Le noeud qui stocke la valeur supprimée est conservé si et seulement si il stocke une autre valeur (il s'agit d'un super-noeud) ou si il a au moins un enfant.
Si un super-noeud ne stocke plus qu'une seule valeur qui est associée à un arbre vide, alors le super-noeud est transformé en noeud simple.

La suppression de valeurs peut conduire à la présence de noeuds simples sans valeurs.
Ces noeuds inutilisées peuvent être apparentés à des \emph{pierres tombales}.
Similairement à \emph{WOOT} et \emph{RGA}, elles nuisent à l'efficacité des opérations exécutées et des messages intégrés sur la séquence.
Toutefois, le plus grand inconvénient de \emph{TreeDoc} réside dans le couplage de ses positions avec sa structure de données.
Dans une écriture séquentielle de gauche à droite ou de droite à gauche l'arbre devient une liste chaînée.
La taille des positions croit rapidement.

\begin{figure}[tb]
\centering
\begin{tikzpicture}
    \renewcommand\widthletter{7mm}
    \newcommand\hsep{1.6};
    \newcommand\vsep{-0.8};
    \node[letter,
            label={below:$A_1$}
        ](l) {$l$};
    \node[letter,
            label={below:$A_2$}
        ](a) at (\hsep,\vsep) {$a$};
    \node[letter,
            label={below:$A_3$}
        ](d) at (2*\hsep,2*\vsep) {$d$};
    \node[letter,crossed,
            label={below:$A_4$}
        ](y) at (3*\hsep,3*\vsep) {$y$};
    \node[letter,
            label={below:$A_6$}
        ](i) at (2*\hsep,4*\vsep) {$i$};
    \node[letter,
            label={below:$A_7$}
        ](e) at (3*\hsep,5*\vsep) {$e$};
    \node[letter,
            label={below:$A_8$}
        ](s) at (4*\hsep,6*\vsep) {$s$};
    \node[letter,
            label={below:$B_1$}
        ](!) at (4*\hsep,4*\vsep) {$\negthinspace!$};
    \draw (l) to node[above,sloped]{$1$} (a);
    \draw (a) to node[above,sloped]{$1$} (d);
    \draw (d) to node[above,sloped]{$1$} (y);
    \draw (y) to node[above,sloped]{$0$} (i);
    \draw (i) to node[above,sloped]{$1$} (e);
    \draw (e) to node[above,sloped]{$1$} (s);
    \draw (y) to node[above,sloped]{$1$} (!);
\end{tikzpicture}
\caption[Exemple d'une séquence \emph{treedoc}]{Exemple d'une séquence \emph{treedoc} de valeurs associées à leurs positions (chemin dans l'arbre) et leurs identifiants.
Les noeuds conservés dont la valeur a été supprimée sont barrés.}\label{fig:treedoc}
\end{figure}

La \autoref{fig:treedoc} correspond à la séquence \emph{Treedoc} obtenue après l'exécution du scénario de la \autoref{fig:replseq-sematic-1}.
Le caractère $\textsf{'\textit{y}'}$ a pour position $111$ et identifiant $A_4$.
Le caractère $\textsf{'\textit{i}'}$ est insérée entre les caractères $\textsf{'\textit{d}'}$ et $\textsf{'\textit{y}'}$.
Un noeud doit donc être créé à gauche de $\textsf{'\textit{y}'}$.
La position de $\textsf{'\textit{i}'}$ est donc $1110$.

\emph{Treedoc} utilise une synchronisation par opérations.
Les messages doivent être livrés exactement une fois et les messages de suppression d'une valeur doivent être livrés après l'insertion de cette valeur.
Les messages d'insertion peuvent être livrés dans un ordre arbitraire.


\paragraph{LogootSplit}\autocite{andre_2013_logootsplit} réduit l'occupation mémoire d'une séquence \emph{Logoot} en groupant les valeurs par \emph{blocs}.
Pour ce faire, \emph{LogootSplit} modifie la structure des positions de telle manière à ce qu'elles puissent être agrégées.
Des valeurs contiguës dans la séquence dont les positions sont agrégeables sont groupées au sein d'un \emph{bloc}.

Une position \emph{LogootSplit} est une liste de quadruples.
L'ordre total et dense des positions est formé par l'ordre lexicographique entre les listes de quadruples et les quadruples.
Un quadruple est composé d'un entier choisit aléatoirement, de l'identifiant du pair qui a généré le quadruple, d'un nombre séquentiel, et d'un indice de bloc.
Dans la \autoref{fig:logootsplit}, le caractère $\textsf{'\textit{\negthinspace!}'}$ est associé à une position qui contient le quadruple $\tuple{20, B, 1, 0}$.
Ce quadruple est noté $t^{B1}_0$ où $t$ est la $20$-ème lettre de l'alphabet latin.
Deux positions sont agrégeables si et seulement si elles partagent la même liste de quadruples, à l'exception des derniers dont les indices de blocs sont différents mais contiguës.
Par exemple, la position $f^{A1}_2q^{A2}_0$ est agrégeable à la position $f^{A1}_2q^{A2}_1$.
Deux valeurs de la séquence peuvent être groupées en un bloc si et seulement si elles sont contiguës dans la séquence et leurs positions sont agrégeables.
Dans la \autoref{fig:logootsplit}, les caractères $\textsf{'\textit{l}'}$, $\textsf{'\textit{a}'}$, et $\textsf{'\textit{d}'}$ sont contiguës et ont des positions agrégeables.
Elles sont regroupées au sein d'un même bloc.
Des positions agrégées sont représentées synthétiquement à l'aide de la position de la première valeur du bloc.
La position d'une valeur peut alors être déduite de la première position du bloc et de son emplacement dans le bloc.
Deux positions agrégeables sont nécessairement générés par le même pair.
Un bloc est donc composés de valeurs insérées par un même pair.
Ce pair est le propriétaire du bloc.
Seul ce pair peut ajouter des valeurs au bloc.
Dans la \autoref{fig:logootsplit}, $p_A$ est le propriétaires des blocs $\textsf{'\textit{lad}'}$ et $\textsf{'\textit{ies}'}$.
$p_B$ est le propriétaire du bloc $\textsf{'\textit{\negthinspace!}'}$.

L'exécution d'une opération d'insertion d'une valeur $v$ produit un message d'insertion qui contient $v$ et la position de $v$.
La position générée est comprises entre le positions $p_1$ et $p_2$ des valeurs $v_1$ et $v_2$ entre lesquelles $v$ doit être insérée.
L'algorithme de génération des positions favorise la génération de positions agrégeables.
Il tente ainsi de produire une position agrégeable à $p_1$ ou $p_2$.
Si il n'y parvient pas, il génère la position de la même manière que \emph{Logoot}.
Lorsque $p_1$ et $p_2$ sont agrégeables, $p_1$ devient un préfixe de la position de $v$.

Une séquence \emph{LogootSplit} est une liste de blocs auxquelles sont associées la position de la première valeur du bloc.
L'intégration d'un message d'insertion d'une valeur $v$ à une position $p$ débute par l'identification de l'emplacement d'insertion.
$v$ doit être insérée entre les valeurs contiguës $v_1$ et $v_2$ tel que la position $p_1$ de $v_1$ est inférieur à $p$ et la positions $p_2$ de $v_2$ est supérieur à $p$.
Nous différencions deux cas principaux~: soit $v_1$ et $v_2$ font partie d'un même bloc, ou ils font partie de blocs distincts.
Dans le premier cas, le bloc est scindé en deux blocs et la valeur est insérée entre ces deux blocs au sein d'un nouveau bloc.
Dans le second cas, la valeur est soit insérée entre les deux blocs ou intégrée à l'un des blocs.
Si $p_1$ et $p$ sont agrégeables, alors $v$ est ajouté en tant que dernière valeur du bloc qui contient $v_1$.
Sinon si $p$ et $p_2$ sont agrégeables, alors $v$ est ajouté en tant que première valeur du bloc qui contient $v_2$.
Sinon, $v$ est insérée entre les deux blocs au sein d'un nouveau bloc.

Pour illustrer la génération de positions et l'intégration de messages d'insertion, nous reprenons le scénario de la \autoref{fig:replseq-sematic-1}.
La séquence \emph{LogootSplit} obtenue est représentée dans la \autoref{fig:logootsplit-1}.
Le pair $p_A$ commence par une insertion contiguëe de plusieurs caractères.
Les positions sont générées de telle manière à être agrégées.
Nous obtenons ainsi le bloc qui contient la chaîne $\textsf{'\textit{lady}'}$.
$p_A$ exécute ensuite l'opération $a_5$ qui insère le caractère $\textsf{'\textit{i}'}$ entre $\textsf{'\textit{d}'}$ et $\textsf{'\textit{y}'}$.
Aucune position agrégeable à la position de l'un des deux caractères ne peut être générée tel qu'elle soit comprise entre les positions des deux valeurs.
La position générée a donc pour préfixe la position du caractère $\textsf{'\textit{d}'}$.
L'intégration de cette insertion produit la scission du premier bloc.
En parallèle, le pair $p_B$ insère le caractère $\textsf{'\textit{\negthinspace!}'}$ à la fin de la séquence après le bloc $\textsf{'\textit{lady}'}$.
Une position agrégeable à $\textsf{'\textit{y}'}$ ne peut être généré étant donné que $p_B$ n'est pas le propriétaire du bloc.

\begin{figure}[tb]
\centering
\begin{subfigure}[b]{0.69\linewidth}
    \centering
    \begin{tikzpicture}
        \node[block,
                label={below:$f^{A1}_{\irange{0}{2}}$}
            ] {$lad$}
        to ++(\widthblock,0) node[block,
                label={below:$f^{A1}_2q^{A2}_{\irange{0}{2}}$}
            ]{$ies$}
        to ++(\widthblock,0) node[letter,
                label={below:$t^{B1}_0$}
            ]{$\negthinspace!$}
        ;
    \end{tikzpicture}
    \caption{}\label{fig:logootsplit-1}
\end{subfigure}
\begin{subfigure}[b]{0.29\linewidth}
    \centering
    \begin{tikzpicture}
        \node[letter,
                label={below:$f^{A1}_3$}
            ]{$y$}
        ;
    \end{tikzpicture}
    \caption{}\label{fig:logootsplit-2}
\end{subfigure}
\caption[Exemple d'une séquence \emph{LogootSplit}]{Exemple d'une séquence \emph{LogootSplit}.
\subref{fig:logootsplit-1} Séquence de valeurs associées à leurs positions.
\subref{fig:logootsplit-2} Valeur supprimée associée à sa position.}\label{fig:logootsplit}
\end{figure}

L'exécution d'une opération de suppression suit la même logique que \emph{Logoot}.
En revanche l'intégration d'un message de suppression peut conduire à la scission d'un bloc en deux.
Pour éviter de générer plusieurs fois la même position, un bloc est associé à l'indice minimal et l'indice maximal des positions des valeurs qui ont été ajoutées au bloc.

L'insertion d'une valeur peut conduire à la scission d'un bloc.
Bien que ce soit possible, \emph{LogootSplit} ne propose pas de fusionner les deux blocs si ils deviennent contiguës.
C'est une situation qui peut survenir lorsque les valeurs qui ont conduit à la scission du bloc sont supprimées.

\emph{LogootSplit} utilise le même modèle de synchronisation que \emph{Logoot}.
Toutefois, pour simplifier son implémentation, il suppose que les insertions d'un même pair sont livrés dans le même ordre que leur génération.

Ce travail a été adapté pour \emph{RGA}\autocite{briot_2016_rgasplit}.



% LSeq


\subsection{Catégorisation des séquences répliquées}

Les \acp{CRDT} séquences attachent à chaque élément des méta-données qui permettent de former l'ordre de la séquence.
Ces méta-données sont générés de telle manière à garantir l'intention des insertions et des suppressions.
Les séquences répliquées que nous avons présenté peuvent être réparties en deux approches~:
%Nous distinguons deux approches qui reposent sur des principes de générations distincts de ces méta-données.

\paragraph{L'approche à pierres tombales}\autocite{oster_2006_woot, roh_2011_rga} identifie chaque valeur avec un identifiant unique et immuable.
Une valeur référence une des valeurs entre lesquelles elle est insérée ou éventuellement les deux.
D'autres méta-données peuvent être ajoutés pour déterminer l'ordre total des valeurs de la séquence.
Cette approche se caractérise généralement par une complexité spatiale constante des méta-données associées aux valeurs.
Cependant, une valeur ne peut être insérée avant l'insertion des valeurs qu'elle référence.
Cette approche est synchronisée par opérations et emploie une livraison causale des opérations.
Elle requiert également la conservation des valeurs supprimées pour permettre l'insertion des valeurs qui les référencent.
Pour ne pas apparaître lors des lectures, ces valeurs sont marquées et deviennent des \emph{pierres tombales}.
Parce qu'elles sont conservées au sein de la séquence répliquée, les pierres tombales réduisent les performances générales de la séquence répliquée lorsque le nombre de suppressions est important.
\emph{WOOT} et \emph{RGA} utilisent cette approche.

\paragraph{L'approche à positions densément ordonnées}\autocite{weiss_2009_logoot, preguica_2009_treedoc, nedelec_2013_lseq} associe à chaque valeur une position unique et immuable.
L'ensemble des positions est densément et totalement ordonné.
Lorsqu'une valeur est insérée entre deux autres valeurs, sa position est générée de telle sorte à ce qu'elle soit comprise entre les positions de ces deux dernières.
Les positions sont indépendantes~: une valeur peut être insérée même si les valeurs entre lesquelles elle a été initialement insérée sont absentes.
Une valeur et sa position peuvent donc être définitivement supprimée.
Cependant, pour encoder un ordre dense, les positions n'ont pas une taille constante.
Au fur et à mesure de la collaboration, la taille des positions croît.
Ce qui réduit les performances de la séquence répliquée.
\emph{Logoot} et \emph{Treedoc} utilisent cette approche.

%\paragraph{} Les \acp{CRDT} des deux approches tentent de minimiser la taille des méta-données associées à chaque valeur.
%Chaque approche a connu des raffinements qui ont conduit à des séquence à granularité variable.
%Les valeurs sont groupées en blocs et les méta-données sont attachées aux blocs au lieu d'être attachées individuellement aux valeurs.

\paragraph{}Les deux familles de séquences répliquées réduisent toutes deux leur occupation mémoire en adoptant une approche à granularité variable~\cite{yu_2012_string-wise-crdt, andre_2013_logootsplit, briot_2016_rgasplit}.
Les valeurs sont groupées en blocs et leurs identifiants sont agrégés.
La réduction est particulièrement notable lorsque les séquences sont utilisées pour l'édition collaborative~\autocite{andre_2013_logootsplit,briot_2016_rgasplit}.

Plusieurs propositions tentent de réduire la taille des positions allouées aux valeurs pour l'approche à positions densément ordonnées.
\textcite{nedelec_2013_lseq} proposent une stratégie de génération des positions qui assurent une complexité spatiale moyenne sous-linéaire.
Cette stratégie a été évalué sur des séquences à granularité fixe.
\textcite{nicolas2020_renaming} proposent de remplacer des positions par de nouvelles positions plus petites à l'aide d'un mécanisme de renommage.


La séquence répliquée que nous proposons utilise l'approche à positions densément ordonnées.



\section{Séquences répliquées synchronisées par différences}\label{sec:delta-seq}

%Les séquences répliquées à positions densément ordonnées exige un ordre d'intégration assez faible.
%Les insertions et les suppressions peuvent être intégrées dans un ordre quelconque à l'exception des couples d'opérations qui concerne une même valeur : l'insertion d'une valeur doit être intégrée avant sa suppression.

Nous proposons une approche générique qui permet d'obtenir des séquences répliquées synchronisées par différences d'états à partir de positions densément ordonnées.
En plus de la croissance de la taille de leurs positions, les séquences obtenues peuvent souffrir d'une croissance linéaire des autres méta-données en fonction d'une nombre d'insertion.
Nous proposons alors un nouveau type de positions qui permet de construire des séquences à granularité variable synchronisées par différences qui réduit la croissance de ces méta-données.
Nous nommons ce protocole de séquences répliquées \emph{Dotted logootSplit}.

Dans un premier temps nous présentons un formalisme qui permet de décrire des positions densément ordonnées.
Nous présentons alors un protocole générique synchronisé par opérations qui se base sur ce formalisme.
Dans un second temps, nous utilisons ce formalisme pour introduire notre protocole générique synchronisé par différences d'états et \emph{Dotted logootSplit}.

%Les \ac{CRDT} synchronisés par différences d'états utilise des messages qui contiennent des états ou des différences d'états.
%Les \ac{CRDT} séquence à positions densément ordonnées dispose déjà de contraintes de livraison faible et leur messages sont proches de différences d'états.
%En particulier les insertions peuvent être intégrées dans un ordre quelconque.
%Nous proposons une adaptation générique de cette approche pour proposer le premier \ac{CRDT} séquence synchronisés par différences d'états.
%
%Nous proposons un formalisme qui permet de modéliser l'approche à positions densément ordonnées et de mieux comprendre la structure des positions.
%A partir de cette formalisme nous définissons un \ac{CRDT} séquence générique synchronisé par différences d'états.
%Nous terminons par la présentation de \emph{Dotted LogootSplit}.


\subsection{Séquences répliquées à identifiants densément ordonnés}\label{subsec:dense-id-seq}

Dans cette section nous introduisons un formalisme qui nous permet de mieux appréhender la structure des positions densément ordonnées des séquences répliquées de la littérature.
Il permet également de clarifier les contraintes de tels positions et de ainsi ouvrir un espace de réflexion sur la structure des positions.

Les séquences répliquées à positions densément ordonnées indexent chaque valeur avec une unique position.
L'ordre entre les valeurs de la séquence est induit par l'ordre total et strict entre leurs positions.
Ces positions respectent plusieurs propriétés que nous décrivons dans les paragraphes suivants.

Dans une séquence, une valeur peut être insérée entre deux autres.
De ce fait, il devrait toujours exister au moins une position entre toute pair de positions.
L'ensemble des positions est donc équipé d'un ordre dense.
Des exemples communs d'ordres denses sont l'ensemble des nombres réels et l'ensemble des nombres rationnels.

Dans un scénario distribué, les pairs peuvent insérer des valeurs de manière concurrente.
Ils peuvent insérer ces valeurs entre le même couple de positions.
Ils peuvent donc utiliser la même position.
Des pairs distincts ne doivent pas pouvoir utiliser les mêmes positions.
L'ensemble des positions doit être partagé entre les pairs.
Un pair choisit une position dans la partie qui lui appartient.
L'ensemble doit être partagé de telle manière à respecter la propriété de densité de l'ordre.
Tout pair est capable de choisir une position entre deux autres positions, même si ces positions ne sont pas incluses dans sa partie.

Lorsqu'une valeur est supprimée de la séquence, la position qui lui a été attachée pourrait être réutilisée pour l'insertion ultérieure d'une valeur.
Cependant, la réutilisation de position peut conduire à des scénarios complexes tel que la suppression et l'insertion de deux valeurs distinctes avec la même position.
Nous supposons donc qu'un pair ne réutilise pas de positions qu'il a préalablement choisit.
Dans la littérature, les protocoles de réplications utilisent généralement un identifiant localement unique au pair.
L'ensemble des positions est donc également partagé par l'ensemble des identifiants locaux.
De nouveau, ce partage ne doit pas compromettre la densité de l'ordre.
Un pair peut choisir une position entre toute pair de positions avec l'identifiant local de son choix.

\begin{definition}[Positions]\label{def:pos}
Soit $\trm{Pos}$ la famille des ensembles de positions.
Un ensemble $P$ est un ensemble de positions, et nous écrivons $P \in \trm{Pos}$, si et seulement si il est équipé des relations et des fonctions suivantes~:
\begin{itemize}
\item $\trm{pid}(p) \in \mathbb{I}$ retourne l'identifiant globalement unique du pair qui possède la position p.

\item $\trm{lid}(p) \in \trm{LID}_P$ retourne l'identifiant localement unique au pair $\trm{pid}(p)$ de la position $p$.
$\trm{LID}_P$ correspond donc à l'ensemble des identifiants locaux.
Il est dénombrable infini.
Cet ensemble dépend de l'ensemble de positions $P$.

\item $id(p) \defeq \tuple*{\trm{\trm{pid}(p), \trm{lid}(p)}}$ retourne l'identifiant globalement unique de la position $p$.
\item un ordre total strict et dense $<_P$.
\begin{equation*}
\forall l <_P u \forall d \in \mathbb{I} \times \trm{LID}_P\ \exists p \in P \qsep l <_P p <_P u \land \trm{uid}(p) = d
\end{equation*}

\item $\trm{pick}_i(l, u, X)$ retourne une position qui appartient au pair t'identifiant $i$, qui n'utilise pas un identifiant local inclut dans l'ensemble fini $X$ et qui est entre les positions $l$ et $u$.
$l$ peut également prendre un élément minimal $\bot_P$ qui est strictement inférieur à toutes les positions.
De même, $u$ peut prendre un élément maximal $\top_P$ qui est strictement supérieur à toutes les positions et à $\bot_P$.
Par souci de lisibilité nous utilisons le même symbole $<$ pour l'ordre de $P$ étendu à ces deux extremums.
\begin{equation*}\begin{split}
    \trm{pick}_{i\;\in\;\mathbb{I}}: \set*{l \in P_{\bot}} \times \set*{u \in P^{\top} \given l < u} \times \set*{X \in \powerfset{\trm{LID_P}}}\\
    \to \set*{p \given l < p < u \land \trm{id}(p) = \tuple*{i, c} \land c \not\in X}
\end{split}\end{equation*}
\end{itemize}
\end{definition}

Dans la littérature, l'ensemble des entiers naturels est souvent utilisé comme identifiants locaux.
En choisissant des nombres consécutifs pour chaque nouvelle position prise, il est possible de représenter de manière concise les identifiants locaux qui ne peuvent pas être utilisés pour la nouvelle position.
En effet, au lieu de passer l'ensemble des nombres utilisés nous pouvons passer leur maximum.
Nous parlons ainsi de nombres séquentiels.
Lorsque les entiers naturels séquentiels sont utilisés comme identifiants locaux, conformément à la littérature, nous parlons de \emph{dot} pour désigner l'identifiant $\trm{id}(p)$ d'une position $p$.

\begin{definition}[Positions $dot$-ifiées]\label{def:dot-pos}
Un ensemble $P$ de positions est un ensemble de positions \emph{dot}-ifiées, et nous écrivons $P \in \trm{DotPos}$, si et seulement si~:
\begin{itemize}
\item L'ensemble des identifiants locaux correspond à l'ensemble des entiers naturels privé de $0$.
\begin{equation*}
    \trm{LID}_P \defeq \mathbb{N}^*
\end{equation*}

\item La spécification de la fonction $\trm{pick}$ peut être raffinée comme suit~:
\begin{equation*}\begin{split}
    \trm{pick}_{i\;\in\;\mathbb{I}}: \set*{l \in P_{\bot}} \times \set*{u \in P^{\top} \given l < u} \times \set*{X \in \powerfset{\trm{\mathbb{N}^*}}}\\
    \to \set*{p \given l < p < u \land \trm{id}(p) = \tuple*{i, \max(X) + 1}}
\end{split}\end{equation*}
\end{itemize}
\end{definition}

\emph{Logoot}~\cite{weiss_2009_logoot} génère un ensemble densément ordonné à partir de listes d'éléments d'un ensemble ordonné et fini $\tuple*{F, <_F}$.
Cette ensemble inclut au moins deux éléments.
L'ensemble de ces listes est équipé d'un ordre lexicographique et le dernier élément de chaque séquence est distinct de l'élément minimal de $F$.
Nous dénotons par $F^*$, l'ensemble $F$ privé de son élément minimal.
Cet ensemble de listes est ainsi dénoté par $\bigcup \set*{F^n \times F^* \given n \in \mathbb{N}}$, que nous abrégeons en $F^{n \in \mathbb{N}} \times F^*$.
L'ordre lexicographique est défini comme suit~:

\begin{equation*}\begin{split}
\MoveEqLeft \forall n, m \in \mathbb{N}_0\ \forall a \in F^n \times F^*\ \forall b \in F^m \times F^* \qsep\\
&a \leq_{\trm{lex}} b \iff \exists k \leq m \qsep (\forall j < k \qsep a_j = b_j) \land (k = n + 1 \lor a_k <_F b_k)
\end{split}\end{equation*}

Une position \emph{Logoot} est une paire qui consiste d'une liste de couples et d'un nombre séquentiel.
Le premier élément de chaque couple est un nombre prioritaire et le second élément est l'identifiant du pair qui est utilise comme désambiguïteur quand deux pairs choisissent en concurrence le même nombre prioritaire.
Le nombre séquentiel est incrémenté après chaque insertion locale et évite ainsi la réutilisation de positions attachées à des valeurs supprimées.
Une position \emph{Logoot} est donc \emph{dot}-ifiée.
Une position est identifiée de manière unique avec le \emph{dot} qui est construit à partir de l'identifiant du pair inclut dans le dernier couple de la position et son nombre séquentiel.
Deux positions sont ordonnées à partir de l'ordre lexicographique entre leurs composantes.
L'ordre est dense étant donné l'extensibilité de la liste et l'exclusion du nombre prioritaire minimal dans le dernier couple de la séquence.
Par exemple, Alice insère une valeur entre les positions $\tuple*{\tuple*{f_A}, 1}$ et $\tuple*{\tuple*{g_B}, 1}$.
Elle génère la position $\tuple*{\tuple*{f_A, h_A}, 2}$.
Remarquons que les nombres prioritaires sont des entiers naturels strictement inférieur à $u$.
$u$ est supérieur ou égal à $2$.

\begin{align}
&\trm{LogootPos}_{u\;\in\;\mathbb{N}^{> 1}} \defeq ({(\mathbb{N}_0^{< u} \times \mathbb{I})}^{n \in \mathbb{N}_0} \times (\mathbb{N}^{* < u} \times \mathbb{I})) \times \mathbb{N}^*\\
&\trm{id}(\tuple*{\set*{\tuple*{\_, i_k}}_{k=0}^m, \trm{n}}) \defeq \tuple*{i_m, n}
\end{align}

\emph{Treedoc}~\autocite{preguica_2009_treedoc} emploie une autre structure de positions.
Il génère un ensemble densément ordonné à l'aide d'un n-uplet de \emph{bits} et de \emph{dots}.
Une position \emph{Treedoc} est une paire.
Le premier élément de la paire est un n-uplets de \emph{bits} et de \emph{dots}.
Le n-uplet se termine toujours par un \emph{bit}.
Le second élément de la paire est un \emph{dot} qui identifie de manière unique la valeur.
Une position \emph{Logoot} est \emph{dot}-ifiée.
L'ordre entre deux positions correspond à l'ordre lexicographique de ces composantes.
Lorsque deux valeurs sont insérées en parallèle au même endroit, elles ont le même n-uplets de \emph{bits} et de \emph{dots}.
Par exemple les valeurs associées aux positions $\tuple{\tuple*{0, 1, 0},A_1}$ et $\tuple{\tuple*{0, 1, 0},B_1}$ ont été insérées en parallèle au même emplacement.
Leur \emph{dot} respectif sert alors de désambiguïteur.
Si une valeur est insérée entre ces deux valeurs, le \emph{dot} de la valeur à gauche fera partie du n-uplets de la position nouvellement générée.
Par exemple la valeur associée à la position $\tuple{\tuple*{0, 1, 0, A_1},A_2}$ se situe entre les deux valeurs précédentes.

\begin{align}
&\trm{TreedocPos} \defeq {({(\mathbb{I} \times \mathbb{N}^*)}^{m \in \set*{0, 1}} \times \set*{0, 1})}^{n \in \mathbb{N}_0} \times (\mathbb{I} \times \mathbb{N}^*)\\
&\trm{id}(\tuple*{\_, \tuple*{i, n}}) \defeq \tuple*{i, n}
\end{align}

Dans le \autoref{ch:background}, nous avons vu que les types de données répliquées pouvaient être synchronisés avec différentes approches.
Le choix du mécanisme de synchronisation précise l'implémentation du type de données.
% talk about networks assumptions

Nous spécifions une séquence à positions densément ordonnées synchronisée par opérations comme une paire dans laquelle le premier élément est un ensemble fini d'associations de positions et de valeurs, et le second élément est un ensemble fini d'identifiants locaux.
Dans le cas de positions \emph{dot}-ifiées, cet ensemble peut être simplement remplacé par un nombre séquentiel.

Pour faciliter l'expression de la spécification, nous définissions la fonction $\trm{nthPos}$ qui retourne la position de la n-ème valeur de la séquence.
Nous définissons également $\trm{posIndex}$ qui donne l'index d'une position.
%Le nombre séquentiel est incrémenté après chaque génération d'une nouvelle position.
%Chaque position générée sur un pair a un nombre séquentiel distinct.

\begin{align}
\MoveEqLeft \forall V \ \forall P \in \trm{Pos} \ \forall m: P \pto V \qsep \trm{dom}(m)\ \textit{is finite} \implies\\
%
&\begin{aligned}
\trm{posIndex}&(m, p) \defeq%
\card*{\set*{l \in \trm{dom}(m) \given l <_P p}}
\end{aligned}\\
%
&\begin{aligned}
\MoveEqLeft \trm{nthPos}(m, k) \defeq p \quad\when k < \card*{m}\\
&\where p \in \trm{dom}(m) \land \trm{posIndex}(m, p) = k
\end{aligned}
%
\end{align}

\begin{figure}[htb]
\begin{align}
&\begin{aligned}
\MoveEqLeft \forall V\ \forall P \in \trm{Pos} \qsep \trm{OpPosSeq}\tuple*{P, V} \defeq \set*{m:P \pto V} \times \powerfset{\trm{LID}_P}\\
&\where \trm{dom}(m)\ \textit{is finite}
\end{aligned}\\
%
&\begin{aligned}
\MoveEqLeft \trm{eval}_i(\tuple*{m, x}, \trm{rd}) \defeq \set*{v_k}_{k=0}^{k=\card*{m} - 1}\\
& \where \tuple*{p_k, v_k} \in m\\
& \where p_k \defeq \trm{nthPos}(m, k)
\end{aligned}\\
%
&\begin{aligned}
\MoveEqLeft \trm{prepare}_i(\tuple*{m,x}, \trm{ins}(j, v)) \defeq \tuple*{\textbf{ins}, p, v}\\
&\where p \defeq \trm{pick}_i(l, u, x)\\
&\where l \defeq \begin{dcases}
  \bot_P & \when k = 0\\
  \trm{nthPos}(m, k - 1) &
\end{dcases}\\
&\where u \defeq \begin{dcases}
  \top_P & \when k = \card*{m}\\
  \trm{nthPos}(m, k) &
\end{dcases}\\
&\where k \defeq \min(j, \card*{m})
\end{aligned}\\
%
&\begin{aligned}
\MoveEqLeft \trm{prepare}_i(\tuple*{m,x}, \trm{del}(j)) \defeq%
\begin{dcases}
\tuple*{\textbf{del}, p} & \when \card*{m} \neq 0\\
\bot_{\trm{Msg}} &
\end{dcases}\\
&\where p \defeq \trm{nthPos}(m, \min(j, \card*{m}))\\
\end{aligned}\\
%
&\begin{aligned}
\MoveEqLeft \trm{integrate}_i(\tuple*{m, x}, \tuple*{\textbf{ins}, p, v}) \defeq%
\begin{dcases}
    \tuple*{m \cup \set*{\tuple*{p, v}}, x \cup \set*{c'}} & \when i = i'\\
    \tuple*{m \cup \set*{\tuple*{p, v}}, x} &
\end{dcases}\\
&\where \tuple*{i', c'} \defeq \trm{id}(p)
\end{aligned}\\
%
&\trm{integrate}_i(\tuple*{m, x}, \tuple*{\textbf{del}, p}) \defeq%
\tuple*{m \sminus \set*{\tuple*{p, m(p)}}, x}
%
\end{align}
\caption{Implémentation générique d'une séquence à positions densément ordonnées synchronisée par opérations}\label{fig:op-densely-id-repseq}
\end{figure}

L'exécution d'une insertion ou d'une suppression se déroule en deux étapes.
Un message est d'abord généré à l'aide de la fonction $\trm{prepare}$.
Le message est ensuite intégré à l'aide de la fonction $\trm{integrate}$. Il est également transmis aux autre pairs qui l'intégrèrent à terme.
Lors de l'exécution de l'insertion d'une valeur $v$ avant la $n$-ème valeur, une position est choisie de telle manière à être comprise entre les positions de la $n-1$-ème valeur et la $n$-ème valeur.
Le message d'insertion est formée par la nouvelle position et la valeur.
L'intégration dune insertion consiste à insérer dans l'association la position et sa valeur.
Si la position a été généré par le pair qui intègre l'insertion, alors l'identifiant local de la position est ajouté à l'ensemble des identifiants locaux.
L'exécution de la suppression de la $n$-ème valeur produit un message de suppression qui inclut uniquement la position de la $n$-ème valeur.
L'intégration de ce message consiste simplement à supprimer l'association liée à cette position.

Les séquences répliquées que nous venons de présenter sont à granularité fixe.
Ils ont un sur-coût important car chaque valeur est associée à une méta-donnée qui correspond à sa position.
La littérature propose différentes approches pour réduire ce sur-coût~\autocite{ andre_2013_logootsplit, briot_2016_rgasplit,nedelec_2013_lseq,nicolas2020_renaming}.
Dans la section suivante nous introduisons l'approche à granularité variable.


\subsection{Séquences répliquées à granularité variable}\label{subsec:strwise-seq}

Les séquences répliquées précédemment présentées associent à chaque valeur une position.
Dans le cas d'édition collaborative de texte, les valeurs sont des caractères.
Le caractère prend moins de mémoire que la position qui lui est associé.
Le support de l'édition collaborative induit donc un coût important en mémoire.
Ce coût se retrouve également en communication puisque chaque message d'insertion contient la valeur et sa position.

Au lieu d'utiliser des caractères en tant que valeurs, certains travaux~\autocite{oster_2006_woot} soulignent que l'utilisation de chaînes de caractères en tant que valeurs est possible.
Cette approche à le désavantage de ne pas permettre l'insertion de caractères au sein de ces chaînes de caractères.
Ce n'est donc pas une approche généralisable à toute applications d'édition collaborative de texte.

L'approche à granularité variable propose de permettre l'agrégation de valeurs et de leurs positions en blocs.
Elles peuvent donc être représentés efficacement en mémoire tout en autorisant leur séparation en plusieurs blocs.
Chaque bloc est indexé par la position associée à la première valeur.
La position de chaque valeur est inférée à partir de cette dernière et de leur indice dans le bloc.

Prenant une position $p$, il existe une unique position $q$ qui est strictement supérieure et aggrégeable à $q$.
Par simplicité nous assumons que $p$ est l'unique position qui est inférieure à $q$ et aggrégeable à $q$.
Par conséquent toute position entre $p$ et $q$ ne peuvent être aggrégé ni avec $p$ ni avec $q$.
Il s'en suit que l'insertion d'une valeur entre deux valeurs qui appartiennent à un bloc conduit à la division du bloc en deux blocs.
Ce type d'insertion produit ainsi trois blocs.

\begin{definition}[Positions Aggrégeable]\label{def:offest-positions}
Un ensemble $P$ de positions est un ensemble de positions \emph{aggrégeables}, et nous écrivons $P \in \trm{AggPos}$, si et seulement si l'ensemble est équipé d'une fonction bijective $\trm{agg}$ qui retourne l'unique position aggrégeable et strictement supérieure à la position passée en paramètre.
\begin{equation*}
    \trm{agg}: \set*{p \in P} \to \set*{q \in P \given p <_P q}
\end{equation*}
\end{definition}
% agg could be a prefix order instead.

\begin{theorem}
Une chaîne de positions aggrégeables peut être déduite à partir de sa première position et de sa longueur.
\end{theorem}

\begin{proof}
Nous procédons par induction. La première position est connue. Supposons que nous connaissions la $n$-ème position de la chaîne que nous notons $p$.
$\trm{agg}(p)$ est l'unique position aggrégeable à $p$ et strictement supérieure à $p$.
Elle correspond ainsi à la $n+1$-ème position de la chaîne.
A partir de la première position $q$ et de la taille $m$ de la chaîne nous pouvons ainsi obtenir la chaîne $\set{p_k \in P \given 0 \leq k < m \land p_0 = q \land \forall 0 \leq i < m-1 \qsep \trm{agg}(p_i) = p_{i+1}}$.
\end{proof}

\textcite{yu_2012_string-wise-crdt} propose le premier type de séquences répliquées à granularité variable.
Cependant, \emph{logootSplit}~\cite{andre_2013_logootsplit} est le premier type de séquences répliquées qui exploite l'idée d'agréger des positions.

Une position \emph{logootSplit} est une liste de n-uplets.
Le premier élément d'un n-uplet est un nombre prioritaire, le second élément est l'identifiant du pair qui a généré le n-uplet, le troisième élément est un nombre séquentiel, et le dernier élément est l'indice de la valeur dans le bloc.
\emph{logootSplit} est construit sur les idées introduites par \emph{Logoot}.
Il utilise le nombre prioritaire pour ordonner les positions.
Dans le cas où deux positions partagent le même nombre prioritaire, elles sont ordonnées par l'identifiant du pair.
Les identifiants des pairs agissent donc comme des désambiguïteurs.
En revanche, il utilise des \emph{dots} pour identifier de manière unique un bloc au lieu d'une valeur.
A chaque fois qu'un nouveau bloc est généré, le nombre séquentiel est incrémenté.
Par exemple, le premier bloc de Alice est identifié par le \emph{dot} $A_1$, et le second par $A_2$.
Une position et par extension la valeur qui lui est associée sont identifiées de manière unique par le \emph{dot} du bloc correspondant et l'indice de la valeur dans le bloc.
Par exemple, $\tuple*{A_1,0}$ et $\tuple*{A_1,1}$ identifient les deux premières valeurs du premier bloc du pair $p_A$.
\emph{LogootSplit} permet d'ajouter des valeurs en début et en fin de blocs.
Il génère ainsi les positions de telles sortes à ce qu'elles soient respectivement aggrégeable avec la première et la dernière position.
Pour ce faire, \emph{LogootSplit} utilise des indices négatifs et positifs.
Par exemple si le pair $p_A$ insère une valeur en début de son premier bloc, la valeur est identifiée par $\tuple*{A_1,-1}$.
Quand une valeur est insérée entre deux valeurs d'un même bloc, le bloc est divisé.
La position générée inclut l'ensemble des n-uplets de la position qui la précède, auquel est joint un nouveau n-uplet.

\begin{align}
&\trm{LogootSplitPos}_u \defeq {(\mathbb{N}_0^{< u} \times \mathbb{I} \times \mathbb{N}_0 \times \mathbb{Z})}^{n \in \mathbb{N}^*} \times \mathbb{N}^{* < u} \times \mathbb{I} \times \mathbb{N}^* \times \mathbb{Z}\\
&\trm{id}(\set*{\tuple*{\_, i_k, n_k, z_k}}_{k=0}^m) \defeq \tuple*{i_m, \tuple*{n_m, z_m}}\\
&\begin{aligned}
    \MoveEqLeft \trm{agg}(\set*{\tuple*{x_k, i_k, n_k, z_k}}_{k=0}^m) \defeq \set*{a_h}_{h=0}^m\\
    &\where a_h = \begin{dcases}
        \tuple*{x_m, i_m, n_m, z_m + 1} & \when h = m\\
        \tuple*{x_h, i_h, n_h, z_h}
    \end{dcases}
\end{aligned}
\end{align}

Nous disposons de l'ensemble des concepts nécessaires à la présentation de notre séquence répliquée.


\subsection{Approche générique}

Dans cette sous-section, nous proposons une approche générique qui permet de synchroniser par différences d'états une séquence répliquée à positions densément ordonnées qui respecte le formalisme présenté dans les sous-sections précédentes.

Les types de données répliqués synchronisés par différences d'états représentent les modifications sous forme de différences d'états.
L'intégration d'une différence d'états consiste donc à la fusion de deux états.
Les états peuvent être fusionnés dans un ordre quelconque et plusieurs fois.
Cette synchronisation est donc parfaitement adaptée à des systèmes de passage de messages non-fiables où les messages peuvent être dupliqués et réordonnées.

Les séquences répliquées à positions densément ordonnées de la littérature sont synchronisées par opérations.
Les opérations doivent être intégrées dans un ordre spécifique et exactement une fois.
Cependant, seuls les couples d'opérations qui concernent une même valeur ont un ordre d'intégration spécifique~: l'insertion d'une valeur doit être intégrée avant sa suppression.

Si nous considérons une séquence qui autorise uniquement des insertions, elle peut donc être aisément synchronisée par différences d'états.
Pour ce faire, il suffit d'insérer une valeur et sa position si et seulement si elle n'est pas déjà présente dans la séquence.
Nous obtenons ainsi la propriété d'idempotence des séquence synchronisées par différences d'états~: une insertion peut être intégrée plusieurs fois.

Lorsque la séquence autorise les suppressions, des valeurs peuvent être supprimées.
Si une insertion d'une valeur est intégrée après sa suppression, la valeur est alors de nouveau insérée.
L'intention de la suppression est ainsi violée.
Pour s'assurer qu'une valeur supprimée est définitivement supprimée, et ce même lorsque son insertion est intégrée ultérieurement, nous devons garder une trace de l'ensemble des valeurs qui ont été insérées dans la séquence.
Nous employons un \emph{contexte causal}~\autocite{almeida_2018_delta-crdt-revisited} qui inclut l'identifiant unique de chaque valeur insérée dans la séquence.
Nous définissons donc le contexte causal comme un ensemble fini d'identifiants de valeurs (\autoref{eq:cc-state}).
Un identifiant d'une valeur correspond à un couple $\tuple*{i, l}$ où $i$ est l'identifiant du pair qui a généré l'identifiant, et $l$ est un identifiant local à ce pair.
La fonction $\trm{lids}$ donne l'ensemble des identifiants locaux présents dans le contexte causal pour un pair donné (\autoref{eq:cc-lids}).

\begin{align}
\trm{CausalContext}\tuple*{P} &\defeq \powerfset{\mathbb{I} \times \trm{LID}_P}\label{eq:cc-state}\\
\trm{lids}_i(c) &\defeq \set*{n \given \tuple*{i, n} \in c}\label{eq:cc-lids}
\end{align}

Lorsqu'une insertion est intégrée, nous vérifions la présence ou l'absence de l'identifiant de la valeur dans le contexte causal.
Si l'identifiant est présent, la valeur a déjà été insérée et éventuellement été supprimée.
Dans ce cas, la séquence reste inchangée.
Si l'identifiant est absent, la valeur n'a pas encore été insérée.
Elle est donc insérée et son identifiant est ajouté au contexte causal.

Lorsqu'une suppression est intégrée, nous différencions deux cas.
Si l'identifiant de la valeur à supprimer est présent dans le contexte causal, alors nous nous assurons que la valeur n'est plus présente dans la séquence.
Si elle l'est nous la supprimons.
Si l'identifiant de la valeur à supprimer est absent du contexte causal, alors nous l'ajoutons simplement au contexte causal.

La \autoref{fig:deltaseq} présente l'implémentation générique d'une séquence synchronisée par différences d'états.
Nous représentons un état d'une telle séquence par un couple $\tuple*{m, c}$ où $m$ associe les positions aux valeurs de la séquence et $c$ est le contexte causal de la séquence (\autoref{eq:deltaseq-state}).
Les messages de synchronisation sont des différences d'états.
L'exécution de l'insertion d'une valeur $v$ à la position $j$ génère une position $p$ entre les positions associées aux $j-1$-ème et $j$-ème valeurs de la séquence.
Le message d'insertion consiste donc en un couple qui contient uniquement l'association de $p$ à la valeur $v$ et un contexte causal qui contient uniquement l'identifiant unique dérivé de la position (\autoref{eq:deltaseq-ins}).
L'exécution de la suppression de la $j$-ème valeur génère un message de suppression qui contient aucune association et un contexte causal qui contient uniquement l'identifiant de la valeur à supprimer (\autoref{eq:deltaseq-del}).

La fusion d'un état $\sigma_1 \defeq \tuple*{m, c}$ avec un état $\sigma_2 \defeq \tuple*{m', c'}$ produit un état $\sigma_3 \defeq \tuple*{m'', c''}$ (\autoref{eq:deltaseq-integr}).
Le contexte causal de $\sigma_3$ corresponds à l'union des contextes causaux de $\sigma_1$ et $\sigma_2$.
Les associations de $\sigma_3$ correspondent à l'intersection de l'ensemble des associations de $\sigma_1$ et de l'ensemble des associations de $\sigma_2$, ainsi que des associations de $\sigma_1$ et $\sigma_2$ dont l'identifiant n'est pas présent respectivement dans le contexte causal de $ \defeq \tuple*{m, c}_2$ et le contexte causal de $\sigma_1$.
Ces deux derniers ajouts permettent d'insérer les valeurs présentes uniquement dans l'un des deux états tout en s'assurant de ne pas insérer des valeurs supprimées dans l'un des deux états.

\begin{figure}[htb]
    \centering
    \begin{align}
    &\begin{aligned}
    \MoveEqLeft\forall V\ \forall P \in \trm{Pos} \qsep \trm{DeltaSeq}\tuple*{P, V} \defeq \set*{m: P \pto V} \times \powerfset{\mathbb{I} \times \trm{LID}_P}\\
    &\where \trm{dom}(m)\ \textit{is finite}
    \end{aligned}\label{eq:deltaseq-state}\\
    %
    &\begin{aligned}
    \MoveEqLeft \trm{eval}_i(\tuple*{m, c}, \trm{rd}) \defeq \set*{v_k}_{k=0}^{k=\card*{m} - 1}\\
    & \where \tuple*{p_k, v_k} \in m\\
    & \where p_k \defeq \trm{nthPos}(m, k)
    \end{aligned}\label{eq:deltaseq-eval}\\
    %
    &\begin{aligned}
    \MoveEqLeft \trm{prepare}_i(\tuple*{m,c}, \trm{ins}(j, v)) \defeq%
    \tuple*{\set*{\tuple*{p, v}}, \set*{\trm{id}(p)}}\\
    &\where p \defeq \trm{pick}_i(l, u, \trm{lids}_i(c))\\
    &\where l \defeq \begin{dcases}
    \bot_P & \when k = 0\\
    \trm{nthPos}(m, k - 1) &
    \end{dcases}\label{eq:deltaseq-ins}\\
    &\where u \defeq \begin{dcases}
    \top_P & \when k = \card*{m}\\
    \trm{nthPos}(m, k) &
    \end{dcases}\\
    &\where k \defeq \min(j, \card*{m})
    \end{aligned}\\
    %
    &\begin{aligned}
    \MoveEqLeft \trm{prepare}_i(\tuple*{m,c}, \trm{del}(j)) \defeq%
    \begin{dcases}
        \tuple*{\emptyset,\set*{\trm{id}(p)}} & \when \card*{m} \neq 0\\
        \tuple*{\emptyset,\emptyset} &
    \end{dcases}\\
    &\where p \defeq \trm{nthPos}(m, \min(j, \card*{m}))
    \end{aligned}\label{eq:deltaseq-del}\\
    %
    &\begin{aligned}
    \MoveEqLeft \trm{integrate}_i(\tuple*{m,c}, \tuple*{m',c'}) \defeq \tuple*{m'',c \cup c'}\\
        &\where m'' \defeq (m \cap m') \cup \set*{\tuple*{p, v} \in m, \tuple*{p', v'} \in m' \given \trm{id}(p) \not\in c', \trm{id}(p') \not\in c}
    \end{aligned}\label{eq:deltaseq-integr}
    \end{align}
    \caption{Implémentation générique d'une séquence synchronisée par différences}\label{fig:deltaseq}
\end{figure}

Les protocoles de synchronisation par différences d'états assurent généralement le modèle de cohérence causal.
Le protocole de réplication peut utiliser cette garantie pour représenter plus efficacement le contexte causal pour certains types de positions.
Une position \emph{Logoot} utilise un nombre séquentiel comme identifiant local.
De ce fait, le contexte causal peut être efficacement représenté par un vecteur de versions~\autocite{parker_1983_versionvector,mattern_1988_timevector}.
Ce vecteur associe à chaque pair l'identifiant de la dernière valeur insérée par le pair correspondant.
D'autres positions, comme les positions \emph{LogootSplit} ne permettent pas cette optimisation.
Le contexte causal croît linéairement au fur et à mesure de l'insertion de valeurs.
Cependant, contrairement aux positions \emph{Logoot}, les positions \emph{LogootSplit} peuvent être agrégées.
Dans \autoref{subsec:dotted-logootsplit}, nous présentons un nouveau type de position qui permet à la fois de représenter efficacement le contexte causal et permet l'agrégation de positions.


\subsection{LogootSplit dot-ifié}\label{subsec:dotted-logootsplit}

Les positions \emph{Logoot} permettent de représenter efficacement le contexte causal par vecteur de versions.
Pour ce faire, chaque valeur est identifiée par un \emph{dot}~: un couple qui consiste d'un pair et d'un nombre séquentiel.
Les positions \emph{LogootSplit} ne permettent pas cette optimisation.
Chaque valeur est identifiée par un couple qui contient un \emph{dot} et un indice.
Le \emph{dot} identifie de manière unique le bloc dans lequel la valeur se trouve.
L'indice correspond alors à l'indice de la valeur dans ce bloc.

Nous proposons un nouveau type de positions qui tente de construire sur les idées introduites par \emph{Logoot} et \emph{LogootSplit}.
Similairement à ces deux approches, nous utilisons des listes de n-uplets ordonnées par leur ordre lexicographique.
Chaque n-uplet consiste d'un nombre prioritaire, de l'identifiant du pair qui a généré le n-uplet et d'un nombre séquentiel. 
Similairement à \emph{Logoot}, chaque valeur est identifiée par un \emph{dot}.
Chaque fois qu'un pair exécute une insertion il incrémente son nombre séquentiel et assigne à la valeur insérée un nouveau \emph{dot}.
Ce \emph{dot} correspond à l'identifiant du pair et le nombre séquentiel du dernier n-uplet de la liste.
Ces positiosn sont donc \emph{dot}-ifiées.

Deux positions sont agrégeables, si et seulement si \begin{inlinelist}\item elles divergent uniquement par leur identifiant local (le nombre séquentiel du dernier n-uplet), et \item elles ont des identifiants locaux contiguës\end{inlinelist}.
Le nombre séquentiel joue à la fois le rôle d'identifiant local et d'indice de bloc.

\begin{align}
&\trm{DottedLogootSplitPos}_u \defeq {(\mathbb{N}_0^{< u} \times \mathbb{I} \times \mathbb{N}^*)}^{n \in \mathbb{N}_0} \times (\mathbb{N}^{* < u} \times \mathbb{I} \times \mathbb{N}^*)\\
&\begin{aligned}
    \MoveEqLeft \trm{agg}(\set*{\tuple*{x_k, i_k, n_k}}_{k=0}^m) \defeq \set*{a_h}_{h=0}^m\\
    &\where a_h = \begin{dcases}
        \tuple*{x_m, i_m, n_m + 1} & \when h = m\\
        \tuple*{x_h, i_h, n_h}
    \end{dcases}
\end{aligned}
\end{align}

La \autoref{fig:dottedlogootsplit} correspond à la séquence \emph{Dotted LogootSPlit} obtenue après l'exécution du scénario de la \autoref{fig:replseq-sematic}.
Le pair $p_A$ commence par une insertion contiguës de plusieurs caractères.
Les positions sont générées de telle manière à être agrégées.
Nous obtenons ainsi le bloc qui contient la chaîne $\textsf{'\textit{lady}'}$.
$p_A$ exécute ensuite l'opération $a_5$ qui insère le caractère $\textsf{'\textit{i}'}$ entre $\textsf{'\textit{d}'}$ et $\textsf{'\textit{y}'}$.
Aucune position agrégeable à la position de l'un des deux caractères ne peut être générée tel qu'elle soit comprise entre les positions des deux valeurs.
La position générée a donc pour préfixe la position du caractère $\textsf{'\textit{d}'}$.
L'intégration de cette insertion produit la scission du premier bloc.
En parallèle, le pair $p_B$ insère le caractère $\textsf{'\textit{\negthinspace!}'}$ à la fin de la séquence après le bloc $\textsf{'\textit{lady}'}$.
Une position agrégeable à $\textsf{'\textit{y}'}$ ne peut être généré étant donné que $p_B$ n'est pas le propriétaire du bloc.

\begin{figure}[tb]
\centering
\begin{subfigure}[b]{0.69\linewidth}
    \centering
    \begin{tikzpicture}
        \node[block,
                label={below:$f^{A}_{\irange{1}{3}}$}
            ] {$lad$}
        to ++(\widthblock,0) node[block,
                label={below:$f^{A}_3 q^{A}_{\irange{5}{7}}$}
            ]{$ies$}
        to ++(\widthblock,0) node[letter,
                label={below:$t^{B}_1$}
            ]{$\negthinspace!$}
        ;
    \end{tikzpicture}
    \caption{}\label{fig:dottedlogootsplit-1}
\end{subfigure}
\begin{subfigure}[b]{0.29\linewidth}
    \centering
    \begin{equation*}
        \set*{A_{\irange{1}{7}},B_1}
    \end{equation*}
    \caption{}\label{fig:dottedlogootsplit-2}
\end{subfigure}
\caption[Exemple d'une séquence \emph{Dotted LogootSplit}]{Exemple d'une séquence \emph{Dotted LogootSplit}.
\subref{fig:logootsplit-1} Séquence de valeurs associées à leurs positions.
\subref{fig:logootsplit-2} Contexte causal de la séquence.}\label{fig:dottedlogootsplit}
\end{figure}

Le \autoref{fig:dottedlogootsplit-semilattice} représente un aperçu du sup-demi-treilli des états de la séquence obtenue dans la \autoref{fig:dottedlogootsplit}.
%Étant donné que les positions sont omises dans le diagramme, il est valide pour tout type de positions \emph{dot}-ifiées.

\begin{figure}[!ht]
\centering
\begin{tikzpicture}
    \matrix[column sep=6.4cm,row sep=2.2cm]{
        & \coordinate(mA3A4rB1); &\\
        \coordinate(mA3A4r); & \coordinate(mA3A4B1); & \coordinate(mA4rB1);\\
         \coordinate(mA3A4); & \coordinate(mA3B1); & \coordinate(mA4B1); \\
        & \coordinate(mA4r); &\\
        \coordinate(mA3); & \coordinate(mA4); & \coordinate(mB1); \\
        & \coordinate(mbot); &\\
    };

    \node (bot) at (mbot) {$\bot$};
    \node[
        label={[name=ccA3]above:$\set*{A_3}$}
    ] (cA3) at (mA3) {$d$};
    \node[
        label={[name=ccA4]above:$\set*{A_4}$}
    ] (cA4) at (mA4) {$y$};
    \node[
        label={[name=ccB1]above:$\set*{B_1}$}
    ] (cB1) at (mB1) {$\negthinspace!$};
    \node (cA4r) at (mA4r) {$\set*{A_4}$};
    \node[
        label={[name=ccA3A4]above:$\set*{A_3,A_4}$}
    ] (cA3A4) at (mA3A4) {$dy$};
    \node[
        label={[name=ccA4B1]above:$\set*{A_4,B_1}$}
    ] (cA4B1) at (mA4B1) {$y!$};
    \node[
        label={[name=ccA3B1]above:$\set*{A_3,B_1}$}
    ] (cA3B1) at (mA3B1) {$d!$};
    \node[
        label={[name=ccA3A4r]above:$\set*{A_3,A_4}$}
    ] (cA3A4r) at (mA3A4r) {$d$};
    \node[
        label={[name=ccA4rB1]above:$\set*{A_4,B_1}$}
    ] (cA4rB1) at (mA4rB1) {$!$};
    \node[
        label={[name=ccA3A4B1]above:$\set*{A_3,A_4,B_1}$}
    ] (cA3A4B1) at (mA3A4B1) {$dy!$};
    \node[
        label={[name=ccA3A4rB1]above:$\set*{A_3,A_4,B_1}$}
    ] (cA3A4rB1) at (mA3A4rB1) {$d!$};

    \foreach \x in {A3,A4,B1}
        \node[draw,rounded corners,fit=(c\x) (cc\x)](\x) {};
    \node[draw,rounded corners,fit=(cA4r)](A4r) {};

    \foreach \x in {A3A4,A3B1,A4B1,A3A4r,A4rB1,A3A4B1,A3A4rB1}
        \node[fit=(c\x) (cc\x)](\x) {};

    \draw (bot) to (A3);
    \draw (bot) to (A4);
    \draw (bot) to (B1);
    \draw (A4) to (A4r);
    \draw (A3) to (A3A4);
    \draw (A3) to (A3B1);
    \draw (A4) to (A3A4);
    \draw (A4) to (A4B1);
    \draw (B1) to (A3B1);
    \draw (B1) to (A4B1);
    \draw (A3A4) to (A3A4B1);
    \draw (A3B1) to (A3A4B1);
    \draw (A4B1) to (A3A4B1);
    \draw (A4r) to (A3A4r);
    \draw (A4r) to (A4rB1);
    \draw (A3A4) to (A3A4r);
    \draw (A4B1) to (A4rB1);
    \draw (A3A4r) to (A3A4rB1);
    \draw (A4rB1) to (A3A4rB1);
    \draw (A3A4B1) to (A3A4rB1);
\end{tikzpicture}
\caption[Sup-demi-treillis des états d'une séquence répliquée synchronisée par états]{Aperçu du diagramme de Hasse du sup-demi-treillis des états de la séquence répliquée synchronisée par états.
Pour simplifier la représentation, les positions associées aux valeurs sont omises.
Les états entourés sont irréductibles.
}\label{fig:dottedlogootsplit-semilattice}
\end{figure}

Nous avons implémenté \emph{Dotted LogootSplit}\footnote{Le code source est disponible sur \emph{GitHub}~: \href{https://github.com/coast-team/dotted-logootsplit}{github.com/coast-team/dotted-logootspli}} et intégré ce protocole de réplication à l'éditeur collaboratif \emph{MUTE}\footnote{\href{https://coedit.re}{coedit.re}}.

\subsection{Discussion}

\emph{LogootSplit} et \emph{Dotted LogootSplit} agrègent leurs positions pour former des blocs et ainsi réduire leur empreinte mémoire.
\emph{LogootSplit} permet au propriétaire d'un bloc d'ajouter des valeurs en début et fin du bloc à tout moment.
\emph{Dotted LogootSplit} ne permet pas l'ajout de valeur en début de bloc et restreint l'ajout en fin de bloc.
Deux positions agrégeables doivent avoir des nombres séquentiels contiguës.
À chaque exécution d'une insertion, le nombre séquentiel est incrémenté.
Un pair est donc dans l'impossibilité d'ajouter une valeur au début d'un de ses blocs étant donné qu'il devrait prendre un nombre séquentiel plus petit que celui de la première valeur du bloc.
Il ne peut pas toujours ajouter une valeur en fin bloc.
En effet, si il a procédé à une insertion à un autre emplacement, son nombre séquentiel devient trop grand pour pouvoir générer une position agrégeable à la position de la dernière valeur du bloc.
Cependant, un· collaborateur·ices à tendance à écrire de manière séquentiel.
Nous conjecturons qu'en pratique cette restriction conduit à très peu d'ajout supplémentaires de blocs.
En revanche la non-possibilité d'ajouter des valeurs en début de blocs est problématique pour certains langues écrites de droite à gauche.


\section{Conclusion}

\emph{Dotted LogootSplit} est le premier \ac{CRDT} séquence synchronisé par différences d'états.
La synchronisation par différences d'états offre une grande flexibilité dans la conception de protocole de synchronisation.
Elle permet en particulier à deux pairs de se synchroniser en échangeant des modifications qui peuvent être librement dupliquées et réordonnées.
L'intégration d'une modification n'a pas besoin d'être retardée jusqu'à l'intégration d'une ou plusieurs autres modifications.
Ce qui devrait permettre d'améliorer le support de l'édition collaborative de texte en simultané.
Pour s'en assurer des expérimentations devraient être menées.
Elle devrait également permettre à des pairs qui se connectent rarement au groupe de se synchroniser plus rapidement en échangeant et intégrant directement leur état.
