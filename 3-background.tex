
\chapter{Fondations}\label{ch:background}

\minitoc{}
\bigskip

Dans ce chapitre, nous introduisons les formalismes et les concepts que nous utilisons pour définir les contributions du \autoref{ch:pruned-log} et du \autoref{ch:dotted-logootsplit}.

Les infrastructures pair-à-pair de collaboration permettent à un nombre important d'individus de collaborer.
Pour ce faire elles reposent sur des protocoles de réplication optimiste.
Les protocoles de réplication optimiste garantissent des \emph{propriétés de cohérence} des copies aux pairs et par extension aux collaborateur·ice·s.
La convergence des copies est l'une de ces propriétés de cohérence.
La \autoref{sec:consistency-spec} introduit le formalisme que nous utilisons pour décrire les propriétés de cohérence.
Notre formalisme étend le formalisme de~\textcite{burckhardt_eventualconsistency_2014} pour prendre en compte la présence d'un adversaire actif.
Les protocoles de réplication garantissent souvent des ensembles communs de propriétés de cohérence.
Pour faciliter l'appréciation de leurs similitudes, les propriétés de cohérence sont réunies sous des ensembles bien définies nommés \emph{modèle de cohérence}.
La \autoref{sec:consistency-spec} présente également un moyen de comparer les modèles de cohérence.
La \autoref{sec:causal-models} présente le modèle de cohérence causale ainsi que les modèles de cohérence sur-lesquelles nous nous reposons pour établir la contribution du \autoref{ch:pruned-log}.

La convergence des copies est une propriété essentielle des protocoles de réplication optimiste.
Dans le \autoref{ch:problematic}, nous avons motivé notre intérêt pour des protocoles qui permettent la convergence des copies sans coordination.
De tels protocoles n'imposent pas aux pairs de dialoguer pour s'entendre sur la manière de résoudre les conflits de modification qui surviennent au cours de la collaboration.
Ils n'ont d'autres choix que d'adopter des résolutions prédéterminées de conflit.
Les protocoles de réplication optimiste décident en général la manière de résoudre un conflit.
Pour faciliter la comparaison des protocoles et leur implémentation, les stratégies de résolution de conflits sont encapsulées au sein de type de données répliquées nommés \acfp{CRDT}.
Les concepteur·ice·s d'applications peuvent ainsi utiliser des type de données prêt à l'emploi.
La \autoref{sec:crdt} présente ces types de données et illustre plusieurs sémantiques de résolution de conflits.

\section{Spécification de modèles de cohérence}\label{sec:consistency-spec}

Un protocole détermine comment un pair peut interagir de manière conforme avec le système.
En délimitant le périmètre d'action des pairs, le protocole garantit des propriétés de cohérence des copies.
\textcite{burckhardt_eventualconsistency_2014} a introduit un formalisme pour décrire des propriétés de cohérence et modéliser l'exécution d'un protocole.
Le formalisme qu'il introduit n'est pas adapté aux environnements soumis à la présence de pairs mal-intentionnés.
Dans la \autoref{subsec:consistency-spec-honest} nous présentons son formalisme avec quelques simplifications.
Nous l'étendons dans la \autoref{subsec:consistency-spec-malicious} pour permettre la description d'exécutions soumises à la présence de comportements mal-intentionnés.

Les propriétés de cohérence sont groupées en ensembles logiques dénommés \emph{modèles de cohérence}.
Les modèles de cohérence sont organisés en hiérarchie de celui qui offre les garanties de cohérence les plus fortes à ceux qui offrent les garantie les plus faibles.

Dans le \autoref{ch:problematic} nous avons distingué les propriétés de sûreté des propriétés de vivacité.
Dans la \autoref{subsec:consistency-spec-liveness-safety} nous montrons comment reconnaître et spécifier ces deux genres de propriétés au sein du formalisme introduit.

%Nous motivons d'abord l'intérêt d'exprimer des garanties de cohérence et nous détaillons le formalisme introduit par \textcite{burckhardt_eventualconsistency_2014}.
%Nous étendons ensuite ce formalisme à des environnement qui tolèrent la présence de pairs mal-intentionnés.
%Nous terminons par définir ce qu'est un modèle de cohérence, comment comparer des modèles de cohérence, et une classification possible des garanties de cohérence entre garanties de vivacité et garanties de sûreté. 

\subsection{Spécification en l'absence de pairs mal-intentionnés}\label{subsec:consistency-spec-honest}

Les collaborateur·ice·s s'attendent à ce que les infrastructures de collaboration leur offrent un certain nombre de garanties de cohérence des copies du contenu partagé.
La \autoref{fig:causal-expectation} illustre un scénario dans lequel Bea s'attend à ce que Alice lise les messages textuels dans l'ordre dans lequel elle les a écrit.
Certains protocoles de réplication optimiste peuvent respecter les attentes de Bea et d'autres peuvent ne pas les respecter.
Les attentes des collaborateur·ice·s sont exprimées sous la forme de propriétés de cohérence.

% EXEMPLE : SMS texting, matrix protocol

\begin{figure}[htb]
\centering
\begin{tikzpicture}
    \newcommand*\hsep{2.2}
    \newcommand*\vsep{-1.4}
    % Peers
    \path node (A) {$p_A$}
        to +(0,\vsep) node (B) {$p_B$}
    ;
    % Timeline ends
    \path (7*\hsep,0) coordinate (aend)
        to +(0,\vsep) coordinate (bend)
    ;
    % Events
    \path (A)
        to +(\hsep,0) node[
            label=above:{$\trm{rd}\emptyset$}
        ] (a1) {$a_1$}
        to +(4*\hsep,0) node[
            label=above:{$\trm{rd}\set*{t_2}$}
        ] (a2) {$a_2$}
        to +(6*\hsep,0) node[
            label=above:{$\trm{rd}\set*{t_1,t_2}$}
        ] (a3) {$a_3$}
    ;
    \path (B)
        to +(\hsep,0) node[
            label=below:{$\trm{rd}\emptyset$}
        ] (b1) {$b_1$}
        to +(2*\hsep,0) node[
            label=below:{$\trm{post}(t_1)$}
        ] (b2) {$b_2$}
        to +(3*\hsep,0) node[
            label=below:{$\trm{post}(t_2)$}
        ] (b3) {$b_3$}
    ;
    % Timelines
    \foreach \src/\dest in {A/a1,a1/a2,a2/a3,B/b1,b1/b2,b2/b3,a3/aend,b3/bend}
        \draw (\src) edge[timeline] (\dest);
\end{tikzpicture}
\caption[Attentes des collaborateur·ice·s]{Alice (pair $p_A$) et Bea (pair $p_B$) discutent sur un fil de discussion répliqué.
Le fil de discussion répliqué supporte une opération d'ajout d'un message textuel $\set*{\trm{post}(\trm{txt}) \given \trm{txt} \in \trm{String} }$, et une opération de lecture $\trm{rd}$.
L'exécution d'une opération de lecture retourne l'ensemble des messages qui ont été ajoutés.
Ainsi l'exécution de l'opération $\trm{post}(t_1)$ permet d'ajouter le message textuel $t_1$ sur le fil de discussion.
Nous notons $\trm{rd} s$ l'exécution d'une opération de lecture suivie de l'ensemble $s$ de messages textuels qu'elle retourne.
Bea ajoute un premier message $t_1$ suivi d'un second message $t_2$.
Elle s'attend à ce que Alice prenne connaissance du premier message avant de prendre connaissance du second message.
Cependant, le protocole ne lui garantit pas cette propriété.
Alice lit le second message avant de lire le premier.}\label{fig:causal-expectation}
\end{figure}

Les propriétés de cohérence sont de différentes natures.
Certaines contraignent l'ordre dans lequel les modifications sont intégrées par les pairs.
D'autres spécifient la valeur retournée par les interrogations des pairs.
Elles expriment toutes des garanties qui sont offertes aux collaborateur·ice·s.
De ce fait, elles s'expriment sur les interactions des collaborateur·ice·s avec le protocole et sur les réponses que le protocole fournit aux collaborateur·ice·s.
Les collaborateur·ice·s interagissent avec le système en exécutant des opérations.
L'ensemble des opérations exécutées forme une \emph{histoire}.
L'histoire de la \autoref{fig:causal-expectation} est constituée des trois opérations de Alice (pair $p_A$) et des trois opérations de Bea (pair $p_B$).

Les collaborateur·ice·s exécutent des opérations de modifications pour altérer l'état du contenu partagé et exécutent des opérations d'interrogation pour observer les effets de leurs modifications.
Nous supposons que tout type de contenu partagé est interrogé avec une unique opération $\trm{rd}$.
Il s'agit de l'\emph{opération de lecture}.

Nous supposons que l'exécution d'une opération se termine et qu'elle se déroule sur un intervalle de temps non-nul.
Les dates de début et de fin d'exécution des opérations sont issues d'une unique horloge à temps continu.
Cette horloge n'a pas d'existence propre au cours d'une exécution réelle.
Nous avons toutefois besoin d'un temps continu et universel pour exprimer certaines propriétés de cohérence.

Lorsque nous raisonnons sur l'exécution d'opérations, nous nous intéressons souvent à l'ordre dans lequel les opérations sont exécutées.
Les dates de début et de fin d'exécution d'une opération fournissent plus d'information que nécessaire.
Pour faciliter le raisonnement sur l'ordre d'exécution des opérations d'une histoire, nous introduisons la relation suivante~:

\paragraph{Retourne-avant~\autocite{burckhardt_eventualconsistency_2014}.} Une relation d'ordre partiel qui rend compte des opérations dont l'exécution ne coïncide pas dans le temps.
Une opération $x$ retourne-avant une opération $y$, et nous écrivons $x \rb y$, si et seulement si l'exécution de $x$ se termine avant que l'exécution de $y$ débute.
Si $x$ ne retourne pas avant $y$ et si $y$ ne retourne pas avant $x$, alors leur exécution coïncide.
La \autoref{fig:rb-example} montre un exemple de deux opérations dont l'exécution coïncide dans le temps.

\begin{figure}[ht]
\centering
\begin{subfigure}{.5\linewidth}
    \centering
    \begin{tikzpicture}
        \newcommand*\hsep{1.6}
        \newcommand*\vsep{-1.4}
        % Peers
        \path node (A) {$p_A$}
            to +(0,\vsep) node (B) {$p_B$}
        ;
        % Timeline ends
        \path (4*\hsep+0.5,0) coordinate (aend)
            to +(0,\vsep) coordinate (bend)
        ;
        % Events
        \path (A)
            to +(1,0) node[
                label=above:{$\trm{rd}\emptyset$},
                timedevt,minimum width=1.5cm
            ] (a1) {}
        ;
        \path (B)
            to +(2,0) node[
                label=below:{$\trm{rd}\emptyset$},
                timedevt,minimum width=1cm
            ] (b1) {}
            to +(8*0.5,0) node[
                label=below:{$\trm{post}(t_1)$},
                timedevt,minimum width=2cm
            ] (b2) {}
        ;
        % Timelines
        \foreach \src/\dest in {A/a1,B/b1,b1/b2,a1/aend,b2/bend}
            \draw[timeline] (\src) to (\dest);
    \end{tikzpicture}
    \caption{}\label{fig:rb-example-1}
\end{subfigure}%
\begin{subfigure}{.5\linewidth}
    \centering
    \begin{tikzpicture}
        \newcommand*\hsep{1.6}
        \newcommand*\vsep{-1.4}
        % Peers
        \path node (A) {$p_A$}
            to +(0,\vsep) node (B) {$p_B$}
        ;
        % Timeline ends
        \path (4*\hsep+0.5,0) coordinate (aend)
            to +(0,\vsep) coordinate (bend)
        ;
        % Events
        \path (A)
            to +(\hsep,0) node[
                label=above:{$\trm{rd}\emptyset$}
            ] (a1) {$\bullet$}
        ;
        \path (B)
            to +(\hsep,0) node[
                label=below:{$\trm{rd}\emptyset$}
            ] (b1) {$\bullet$}
            to +(3*\hsep,0) node[
                label=below:{$\trm{post}(t_1)$}
            ] (b2) {$\bullet$}
        ;
        % Timelines
        \foreach \src/\dest in {A/a1,B/b1,a1/aend,b2/bend}
            \draw[timeline] (\src) to (\dest);
        % returns-before
        \draw[-latex] (a1) to node[above,sloped] {\footnotesize rb} (b2);
        \draw[-latex] (b1) to node[above,sloped] {\footnotesize rb} (b2);
    \end{tikzpicture}
    \caption{}\label{fig:rb-example-2}
\end{subfigure}
\caption[Relation retourne-avant d'une histoire]{\subref{fig:rb-example-1} L'intervalle de temps sur lequel l'opération d'interrogation de Alice ($p_A$) s'exécute a une intersection non-nulle avec l'intervalle de temps sur lequel l'opération d'interrogation de Bea ($p_B$) s'exécute.
Ces deux opérations coïncident donc dans le temps.
En revanche, l'intervalle de temps sur lequel l'opération de modification de Bea s'exécute a une intersection nulle avec les deux opérations d'interrogation.
Elle ne coïncide donc pas dans le temps avec ces deux opérations d'interrogation.
Dans ce manuscrit, les propriétés de cohérence que nous exprimons ne nécessitent pas la connaissance de l'intervalle de temps sur lequel une opération s'exécute.
\subref{fig:rb-example-2} Nous contractons donc les intervalles en des points.
Deux points alignés verticalement correspondent à des opérations dont l'exécution coïncide dans le temps.
Si l'exécution de deux opérations ne coïncide pas, alors une opération \emph{retourne-avant} l'autre.
Ici, cette information est explicitement marquée par l'utilisation de la relation \emph{retourne-avant} $\rb$.}\label{fig:rb-example}
\end{figure}

\paragraph{}La \autoref{def:history} définit formellement une histoire.
Elle définit en particulier les caractéristiques associées aux opérations.
La \autoref{tab:op-attributes} donne les caractéristiques des opérations de l'histoire de la \autoref{fig:causal-expectation}.

\begin{definition}[histoire~\autocite{burckhardt_eventualconsistency_2014}]\label{def:history}
Une \emph{histoire} d'un contenu partagé de type $T$ est un n-uplet $H \defeq \tuple*{E, \trm{peer}, \trm{call}, \trm{rval}, \trm{rb}}$ tel que $E$ est un ensemble dénombrable d'opérations.
Pour toute opération $x$~:
\begin{itemize}
\item $\trm{peer}(x) \in \trm{Peers}$ est l'auteur de l'opération $x$.
\item $\trm{call}(x) \in \trm{Op}_T$ est l'appel effectué par l'auteur de $x$.
Ces appels dépendent de $T$.
\item $\trm{rval}(x) \in \trm{Val}_T$ est la valeur de retour de l'appel de $x$ si il s'agit d'une interrogation.
Ces valeurs de retour dépendent de $T$.
\end{itemize}
\begin{itemize}[leftmargin=*]
\item[] $\trm{rb} \subseteq E \times E$ est la relation \emph{retourne-avant}.
Il s'agit d'un ordre partiel localement fini\footnote{Pour tout couple d'opérations, l'ensemble des opérations comprises entre ces 2 opérations est fini.} qui peut être interprété sur une ligne de temps\footnote{\textcite{greenough_1976_semiorder} parle d'ordre d'intervalle.}~:
\begin{equation*}
    u \rb v \land y \rb z \implies u \rb z \lor y \rb v
\end{equation*}
\end{itemize}
\end{definition}

\begin{table}[ht]
    \centering
    \begin{tabular}{cccc}
        opération & $\trm{peer}$ & $\trm{call}$ & $\trm{rval}$ \\
        \toprule
        $a_1$ & $p_A$ & $\trm{rd}$ & $\emptyset$ \\
        $a_2$ & $p_A$ & $\trm{rd}$ & $\set*{t_2}$ \\
        $a_3$ & $p_A$ & $\trm{rd}$ & $\set*{t_1, t_2}$ \\
        $b_1$ & $p_B$ & $\trm{rd}$ & $\emptyset$ \\
        $b_2$ & $p_B$ & $\trm{post}(t_1)$ & \\
        $b_3$ & $p_B$ & $\trm{post}(t_2)$ & \\
    \end{tabular}
    \caption[Caractéristiques des opérations exécutées dans l'histoire de la \autoref{fig:causal-expectation}]{Caractéristiques des opérations exécutées dans l'histoire de la \autoref{fig:causal-expectation}.
    Un fil de discussion supporte une opération de lecture et une opération de modification $\trm{Op}_T = \set*{\trm{rd}} \cup \set*{\trm{post}(\trm{msg}) \given \trm{msg} \in \trm{String}}$.
    Les valeurs de retour correspondent à des ensembles de messages $\trm{Val}_T = \powerfset{\trm{String}}$. $\powerfset{\trm{String}}$ est l'ensemble des sous-ensembles finis des chaînes de caractères.}\label{tab:op-attributes}
\end{table}

Un protocole garantit une propriété de cohérence si et seulement si toutes les histoires qu'il peut produire vérifient cette propriété.
Une histoire vérifie une propriété de cohérence si et seulement si ses caractéristiques (valeur de retour des opérations, ordre d'exécution, \ldots) peuvent être expliquées par l'ajout de la relation suivante~:

\paragraph{Visibilité~\autocite{burckhardt_eventualconsistency_2014}.} Une relation qui rend compte de l'intégration des effets des opérations de modification par les pairs.
Si une opération de modification $x$ est visible à une opération d'interrogation $y$, alors $x$ a (éventuellement) un effet sur la valeur de retour de $y$.
Nous disons aussi que l'effet de $x$ a été intégré à la copie avant l'exécution de l'opération $y$ sur cette même copie.
%Si une opération $x$ est visible à une opération $y$ alors la première a été intégrée par le pair avant l'exécution de $y$.
Dans ce cas, nous écrivons $x \vis y$.
La relation de visibilité n'est pas forcément transitive.
Par exemple, dans la \autoref{fig:vis-example}, $b_2$ est visible à $b_3$ et $b_3$ est visible à $a_2$, mais $b_2$ n'est pas visible à $a_2$.
Par souci de concision, nous écrivons $x \viseq y$ si $x$ est visible ou est égal à $y$.

% Nous pourrions nous contenter des histoires pour exprimer des propriétés de cohérences.
% En procédant de la sortes nos propriétés mélangent des contraintes d'ordre et des contraintes de type.
% Afin de séparer les contraintes nous exprimant nos propriétés de cohérence à l'aide d'exécution abstraites.

\paragraph{} Une histoire augmentée de la relation de \emph{visibilité} consiste en une \emph{exécution abstraite}~\autocite{burckhardt_eventualconsistency_2014}.
La \autoref{def:abstract-exec} définit formellement une exécution abstraite.
La \autoref{fig:vis-example} est une exécution abstraite de l'histoire de la \autoref{fig:causal-expectation}.

\begin{definition}[exécution abstraite~\autocite{burckhardt_eventualconsistency_2014}]\label{def:abstract-exec}
Une \emph{exécution abstraite} d'un contenu partagé de type $T$ est un n-uplet $A \defeq \tuple*{H, \trm{vis}}$ tel que~:
\begin{itemize}
  \item $H$ est une histoire d'un contenu partagé de type $T$.

  \item $\trm{vis} \subseteq H \times H$ est la relation de \emph{visibilité}. Elle est sans cycle et localement finie.
\end{itemize}
\end{definition}

\begin{figure}[bth]
\centering
\begin{tikzpicture}
    \newcommand*\hsep{2.2}
    \newcommand*\vsep{-1.4}
    % Peers
    \path node (A) {$p_A$}
        to +(0,\vsep) node (B) {$p_B$}
    ;
    % Timeline ends
    \path (7*\hsep,0) coordinate (aend)
        to +(0,\vsep) coordinate (bend)
    ;
    % Events
    \path (A)
        to +(\hsep,0) node[
            label=above:{$\trm{rd}\emptyset$}
        ] (a1) {$a_1$}
        to +(4*\hsep,0) node[
            label=above:{$\trm{rd}\set*{t_2}$}
        ] (a2) {$a_2$}
        to +(6*\hsep,0) node[
            label=above:{$\trm{rd}\set*{t_1,t_2}$}
        ] (a3) {$a_3$}
    ;
    \path (B)
        to +(\hsep,0) node[
            label=below:{$\trm{rd}\emptyset$}
        ] (b1) {$b_1$}
        to +(2*\hsep,0) node[
            label=below:{$\trm{post}(t_1)$}
        ] (b2) {$b_2$}
        to +(3*\hsep,0) node[
            label=below:{$\trm{post}(t_2)$}
        ] (b3) {$b_3$}
    ;
    % Timelines
    \foreach \src/\dest in {A/a1,a1/a2,a2/a3,B/b1,b1/b2,a3/aend,b3/bend}
        \draw[timeline] (\src) to (\dest);
    % Visibility
    \draw[vis] (b2) to node[above] {\footnotesize vis} (b3);
    \draw[vis] (b3) to node[above,sloped] {\footnotesize vis} (a2);
    \draw[vis,bend left=40] (b2) to node[above,sloped] {\footnotesize vis} (a3);
    \draw[vis] (b3) to node[above,sloped] {\footnotesize vis} (a3.south west);
\end{tikzpicture}
\caption[Exécution abstraite]{Une \emph{exécution abstraite} de l'histoire de la \autoref{fig:causal-expectation}.
La relation \emph{retourne-avant} est inférée par le positionnement horizontal des opérations.
}\label{fig:vis-example}
\end{figure}

Une histoire vérifie une propriété de cohérence si et seulement si il existe au moins une exécution abstraite qui la respecte.
Il suffit donc de générer toutes les exécutions abstraites possibles pour une histoire donnée et vérifier que au moins l'une d'entre elles respecte la propriété de cohérences considérée.
La \autoref{fig:hist-absexec} met en évidence les relations entre histoires, exécutions abstraites, et propriétés de cohérence.

\begin{figure}[tbh]
\centering
\newcommand*\psep{1}
\newcommand*\bsq{\scriptscriptstyle\blacksquare}
\begin{tikzpicture}
    \begin{scope}[inner sep=0]
        % histories
        \path (0,0) node{$\bullet$}
            to +(30:\psep) node (h3) {$\bullet_1$}
            to +(90:\psep) node {$\bullet$}
            to +(150:\psep) node {$\bullet$}
            to +(210:\psep) node {$\bullet$}
            to +(270:\psep) node {$\bullet$}
            to +(330:\psep) node (h6) {$\bullet_2$}
            ;
        % abstract exec
        \path (7,0) node (A4) {$\bsq_2$}
            to +(0:\psep) node (A5) {$\bsq$}
            to +(120:\psep) node (A1) {$\bsq_1$}
            to +(180:\psep) node (A3) {$\bsq$}
            to +(240:\psep) node (A7) {$\bsq_3$}
            ;
        \path (7 + 2*\psep,0) node (A6) {$\bsq$}
            to +(120:\psep) node (A2) {$\bsq$}
            to +(240:\psep) node (A8) {$\bsq_4$}
            ;
    \end{scope}
    \begin{scope}[rounded corners]
        % boxes
        \node[
            draw, fit=(h3) (h6),
            pin={-100:{du protocole $P$}}
        ] {};
        \node[
            draw, fit=(A1) (A3) (A4) (A7),
            pin={-100:{respectant $p_1$}}
        ] {};
        \node[
            draw, fit=(A2) (A5) (A6) (A8),
            pin={-80:{respectant $p_2$}}
        ] {};
        \node[
            draw, fit=(A4) (A5),
            pin={[pin distance=50]30:{respectant $p_3$}}
        ] {};
    \end{scope}
    \begin{scope}[bend left=10]
        % relations
        \draw (h3) to (A1);
        \draw (h3) to (A4);
        \draw (h6) to (A7);
        \draw (h6) to (A8);
    \end{scope}
    % sep
    \draw (3,2.5) node[
            label={below left:{ensemble des \emph{histoires}}},
            label={below right:{ensemble des \emph{exécutions abstraites}}},
        ] {}
        to +(0,-5)
        ;
\end{tikzpicture}
\caption[Relations entre protocoles, histoires, exécutions abstraites, et propriétés de cohérence]{Illustration des relations entre protocoles, histoires, exécutions abstraites, et propriétés de cohérence.
L'exécution du protocole $P$ peut produire les histoires $\bullet_1$ et $\bullet_2$.
$\bsq_1$ et $\bsq_2$ correspondaient aux exécutions abstraites que nous obtenons à partir de $\bullet_1$.
$\bsq_3$ et $\bsq_4$ correspondaient aux exécutions abstraites que nous obtenons à partir de $\bullet_2$.
L'histoire $\bullet_1$ vérifié les propriétés de cohérence $p_1$ et $p_3$ puisque l'exécution abstraite $\bsq_2$ les respectent.
De même, l'histoire $\bullet_2$ vérifié la propriété $p_1$ ou $p_2$ puisque l'exécution abstraite $\bsq_3$ respecte $p_1$ et l'exécution abstraite $\bsq_4$ respecte $p_2$.
Le protocole $P$ garantit ainsi la propriété $p_1$ puisque chacune de ses histoires est associée à au moins une exécution abstraite qui la respecte.}\label{fig:hist-absexec}
\end{figure}

La relation de visibilité rend compte de l'intégration des effets des opérations de modification par les pairs.
En tant que tel, seules les relations de visibilité dirigées d'une opération de modification vers une opération d'interrogation semblent faire sens.
Dans la \autoref{fig:vis-example} on remarque ainsi que l'effet de l'opération $b_3$ est pris en compte par l'opération de lecture $a_2$, et les effets des opérations $b_2$ et $b_3$ sont pris en compte par l'opération de lecture $a_3$.
Notre définition de la relation de visibilité nous permet de mettre en relation tout type d'opérations.
Dans la \autoref{fig:vis-example} il existe ainsi une relation de visibilité entre les opérations de modification $b_2$ et $b_3$.
Cette flexibilité nous permet de simplifier l'expression des propriétés de cohérence.

Les relations précédemment définies sont suffisantes pour exprimer toutes les propriétés de cohérence auxquelles nous nous intéressons dans ce manuscrit\footnote{\textcite{burckhardt_eventualconsistency_2014} ajoute également une relation d'arriération $\trm{ar}$ à ses exécutions abstraites. Elle s'avère utile dans la définition de certains type de données répliquées. Nous l'avons délibérément omise par souci de simplification.}.
Ces expressions peuvent parfois être peu lisibles.
Par exemple, pour spécifier le type de retour d'une opération de lecture, il est nécessaire de prendre en compte l'ensemble des opérations de modification qui sont visibles à cette opération de lecture.
Dans la \autoref{fig:vis-example}, si un ajout de message textuel est visible à une opération de lecture, alors cette dernière inclut ce message dans sa valeur de retour.
Pour faciliter l'expression de telles propriétés, nous introduisons dans la \autoref{def:op-context} le \emph{contexte} d'une opération.
Le contexte d'une opération regroupe les opérations de modifications qui lui sont visibles.
La \autoref{tab:op-ctx-obs} donne le contexte des opérations de l'exécution abstraite de la \autoref{fig:vis-example}.

\begin{definition}[Contexte]\label{def:op-context}
Le \emph{contexte} d'une opération $x$ dans une \emph{exécution abstraite} $A$, dénoté par $\trm{ctx}_A(x)$, correspond à l'ensemble des opérations de modification\footnote{\textcite{burckhardt_eventualconsistency_2014,viotti_consistency_2016} incluent également les opérations d'interrogation dans le contexte d'une opération. Nous les excluons pour simplifier l'expression de certaines propriétés de cohérence.} qui lui sont visibles.
\begin{equation*}
    \trm{ctx}_A(x) \defeq \set*{y \in A \given y \vis x \land \trm{op}(y) \neq \trm{rd}}
\end{equation*}
\end{definition}

\begin{table}[htb]
    \centering
    \begin{tabular}{ccc}
        Opération & $\trm{ctx}$ & $\trm{obs}$ \\
        \toprule
        $a_1$ & $\emptyset$ & $\set*{p_A}$ \\
        $a_2$ & $\set*{b_3}$ & $\set*{p_A}$ \\
        $a_3$ & $\set*{b_2, b_3}$ & $\set*{p_A}$ \\
        $b_1$ & $\emptyset$ & $\set*{p_B}$ \\
        $b_2$ & $\emptyset$ & $\set*{p_A, p_B}$ \\
        $b_3$ & $\emptyset$ & $\set*{p_A, p_B}$ \\
    \end{tabular}
    \caption{Contexte et observateurs des opérations de l'exécution abstraite de la \autoref{fig:vis-example}.}\label{tab:op-ctx-obs}
\end{table}

La spécification du type de données répliquées de la \autoref{fig:causal-expectation} (fil de discussion) peut ainsi être exprimé par l'\autoref{eq:chat-spec}~:

\begin{equation}\label{eq:chat-spec}
    x \in A \land \trm{call}(x) = \trm{rd} \implies \trm{rval}(x) = \set*{t \given \exists y \in \trm{ctx}_A(x) \qsep \trm{call}(y) = \trm{post}(t)}
\end{equation}

L'exécution abstraite de la \autoref{fig:vis-example} respecte cette propriété de cohérence.
L'histoire de la \autoref{fig:causal-expectation} respecte donc cette propriété de cohérence.


%Un protocole définit les opérations que les pairs peuvent exécuter.
%Lors d'une exécution d'un protocole, les pairs exécutent ainsi un ensemble d'opérations.
%Ces opérations forment l'histoire de l'exécution.
%Le protocole garantit une propriété de cohérence des copies si l'ensemble des histoires qui peuvent être obtenues lors de son exécution vérifient cette propriété.
%Les exécutions abstraites facilitent la définition et la vérification des propriétés de cohérence.
%Une exécution abstraite consiste en une histoire augmentée de la relation de visibilité.
%La relation de visibilité rend compte de l'intégration des opérations modifications par les pairs.
%À une histoire correspond plusieurs exécutions abstraites.
%Il suffit qu'une exécution abstraite respecte une propriété de cohérence pour que l'histoire qui lui correspond la vérifie également.
%Les propriétés de cohérence sont de simples prédicats définit sur les exécutions abstraites.

Le formalisme présenté nous permet de définir des propriétés de cohérence comme de simples prédicats sur des exécutions abstraites.
Des propriétés de cohérence sont garanties par un protocole si chaque histoire du protocole peut être augmentée en une exécution abstraite qui les respecte toutes.
~\textcite{burckhardt_eventualconsistency_2014} a défini les histoires et les exécutions abstraites avec l'hypothèse que les pairs  suivent le protocole.
Nous proposons de généraliser le formalisme pour qu'il puisse être utilisé en présence de pairs qui peuvent déroger au protocole.
Nous qualifions ces pairs de mal-intentionnés.


\subsection{Spécification en présence de pairs mal-intentionnés}\label{subsec:consistency-spec-malicious}

%Un protocole offre des garanties de cohérence uniquement aux pairs qui le suivent, c'est à dire aux pairs honnêtes.
%Les pairs mal-intentionnés peuvent librement déroger à un protocole.
%Ils peuvent par exemple exécuter des opérations qui ne sont pas reconnues par le protocole.
%
%Il n'est donc pas nécessaire de relever l'ensemble des interactions initiées par les pairs mal-intentionnés. Nous nous intéressons uniquement aux opérations qui sont prises en compte par les pairs honnêtes.
%Il s'agit des opérations observées par au moins un pair honnête.

Dans cette section nous proposons une extension du formalisme de \textcite{burckhardt_eventualconsistency_2014}.
Cette extension permet de décrire des exécutions dans lesquels des pairs peuvent déroger au protocole.
Nous qualifions ces pairs de \emph{mal-intentionnés}.
Inversement, les pairs qui suivent le protocole sont qualifiés d'\emph{honnêtes}.
Nous notons $\trm{Honest}$ et $\trm{Malicious}$ l'ensemble des pairs honnêtes et mal-intentionnés.
L'union de ces deux ensemble correspond à l'ensemble des pairs $\trm{Peers}$.
Ces ensembles sont connus étant donné que nous décrivons des exécutions d'un point de vue global.

Sans perte de généralité, nous supposons que les pairs honnêtes exécutent les opérations de manière séquentielle.
Les opérations exécutées sur un même pair sont donc linéairement ordonnées selon la relation \emph{retourne-avant}.
Elles forment une énumération.
Les opérations d'un pair honnête peuvent donc être numérotées dans l'ordre dans lequel elles sont exécutées.
Dans la \autoref{fig:vis-example} on observe ainsi deux énumérations $a_1 \rb a_2 \rb a_3$ et $b_1 \rb b_2 \rb b_3$.
Une histoire qui remplie cette condition est une \emph{histoire bien-formée}.
La \autoref{def:wf-history-malicious} définit formellement une histoire bien-formée.

\begin{definition}[histoire bien-formée]\label{def:wf-history-malicious}
En présence de pairs mal-intentionnés, une histoire $H$ est \emph{bien-formée} si et seulement si pour tout pair honnête $h$, la projection de la relation \emph{retourne-avant} sur $h$ forme une énumération.
%$\tuple*{H|_p, \trm{rb}}$ est une énumération pour tout pair honnête $p$.
%$H|_p$ correspond à l'ensemble des opérations exécutées sur le pair honnête $p$.
\begin{equation*}
x, y \in H \land \trm{peer}(x) \in \trm{Honest} \land \trm{peer}(x) = \trm{peer}(y) \implies x \rb y \lor y \rb x
\end{equation*}
\end{definition}

Les pairs mal-intentionnés peuvent librement déroger à un protocole.
Ils peuvent par exemple~:
\begin{itemize}
    \item Exécuter des opérations qui ne se terminent pas
    \item Exécuter des opérations qui ne sont pas reconnues par le protocole
    \item Produire des interactions qui ne peuvent pas être caractérisées par des opérations
\end{itemize}
Un protocole offre des garanties de cohérence uniquement aux pairs qui le suivent, c'est-à-dire aux pairs honnêtes.
Ces garanties se vérifient donc sur ce que les pairs honnêtes prennent en compte.
Seuls les interactions acceptées par les pairs honnêtes sont incluses dans une histoire.

Les pairs honnêtes acceptent uniquement les interactions reconnues par le protocole.
En d'autres termes ils rejettent toutes les interactions qui ne correspondent pas à des opérations définies par le protocole.
Au sein d'une exécution abstraite, une opération est acceptée par les pairs honnêtes si et seulement si elle est exécutée par un pair honnête ou si elle est visible à au moins une opération exécutée par un pair honnête.
Une opération acceptée est ainsi observée par au moins un pair honnête.
La \autoref{def:op-obs} définit ce qu'est un observateur d'une opération.
La \autoref{tab:op-ctx-obs} donne les observateurs de chaque opération de l'histoire de la \autoref{fig:causal-expectation}.

\begin{definition}[Observateurs]\label{def:op-obs}
Soit une opération $x$ d'une exécution abstraite $A$.
Un pair $p$ est un observateur de $x$ si et seulement si \begin{inlinelist}\item $p$ a exécuté $x$ ou \item $p$ a exécuté une opération de $A$ tel que $x$ est visible à cette dernière\end{inlinelist}.
$\trm{obs}_A(x)$ désigne l'ensemble des observateurs de $x$.
\begin{equation*}
  \trm{obs}_A(x) \defeq \set*{ \trm{peer}(y) \given y \in A \land x \viseq y}
\end{equation*}
\end{definition}

Une \emph{exécution abstraite bien-formée} inclut uniquement les opérations qui sont observées par les pairs honnêtes.
Ces opérations correspondent \begin{inlinelist}
    \item aux opérations exécutées par les pairs honnêtes et
    \item aux opérations exécutées par des pairs mal-intentionnés qui sont visibles à au moins une opération d'un pair honnête
\end{inlinelist}.
La \autoref{def:wf-abstract-exec-malicious} définit formellement une exécution abstraite bien-formée.
La \autoref{fig:wf-example} donne un exemple d'exécution abstraite mal-formée et d'une exécution abstraite bien-formée.
%Les pairs mal-intentionnés peuvent exécuter des opérations qui ne se terminent pas.
%Parce qu'elles ne se terminent pas, elles ne peuvent pas être observées par d'autres pairs, en particulier par les pairs honnêtes.
%Les pairs mal-intentionnés peuvent exécuter des opérations arbitraires.
%Les pairs honnêtes observent uniquement les opérations possible pour le contenu qu'ils partagent.

\begin{definition}[exécution abstraite bien-formée]\label{def:wf-abstract-exec-malicious}
    En présence de pairs mal-intentionnés, une \emph{exécution abstraite} $A \defeq \tuple*{H, \trm{vis}}$ est \emph{bien-formée} si et seulement si~:
    \begin{description}
      \item[\namedlabel{itm:bf1}{BF1}] $H$ est une \emph{histoire bien-formée}.
    
      \item[\namedlabel{itm:bf2}{BF2}] Les opérations dans $E$ des pairs mal-intentionnés sont chacune visible à au moins une opération d'un pair honnête.
      \begin{equation*}
        x \in A \land \trm{peer}(x) \notin \trm{Honest} \implies \trm{obs}_A(x) \cap \trm{Honest} \neq \emptyset
        %\exists y \in A \qsep x \vis y \land \trm{peer}(y) \in \trm{Honest}
      \end{equation*}
    \end{description}
\end{definition}

\begin{figure}[tbh]
\centering
\begin{subfigure}{.5\linewidth}
    \centering
    \begin{tikzpicture}
        \newcommand*\hsep{1.5}
        \newcommand*\vsep{-1.2}
        % Peers
        \path node (A) {$p_A$}
            to +(0,\vsep) node (M) {$p_M$}
            to +(0,2*\vsep) node (B) {$p_B$}
        ;
        % Timeline ends
        \path (4*\hsep,0) coordinate (aend)
            to +(0,\vsep) coordinate (mend)
            to +(0,2*\vsep) coordinate (bend)
        ;
        % Events
        \path (A)
            to +(\hsep,0) node[] (a1) {$a_1$}
        ;
        \path (M)
            to +(2*\hsep,0) node[] (m1) {$m_1$}
        ;
        \path (B)
            to +(\hsep,0) node[] (b1) {$a_1$}
        ;
        % Timelines
        \foreach \src/\dest in {A/a1,B/b1,M/m1,a1/aend,b1/bend,m1/mend}
            \draw[timeline] (\src) to (\dest);
        % visibility
        \draw[vis] (a1) to node[above,sloped] {\footnotesize vis} (m1);
        \draw[vis] (b1) to node[above,sloped] {\footnotesize vis} (m1);
    \end{tikzpicture}
    \caption{}\label{fig:wf-example-1}
\end{subfigure}%
\begin{subfigure}{.5\linewidth}
    \centering
    \begin{tikzpicture}
        \newcommand*\hsep{1.5}
        \newcommand*\vsep{-1.2}
        % Peers
        \path node (A) {$p_A$}
            to +(0,\vsep) node (M) {$p_M$}
            to +(0,2*\vsep) node (B) {$p_B$}
        ;
        % Timeline ends
        \path (4*\hsep,0) coordinate (aend)
            to +(0,\vsep) coordinate (mend)
            to +(0,2*\vsep) coordinate (bend)
        ;
        % Events
        \path (A)
            to +(\hsep,0) node[] (a1) {$a_1$}
            to +(3*1.5,0) node[] (a2) {$a_1$}
        ;
        \path (M)
            to +(2*\hsep,0) node[] (m1) {$m_1$}
        ;
        \path (B)
            to +(\hsep,0) node[] (b1) {$a_1$}
        ;
        % Timelines
        \foreach \src/\dest in {A/a1,a1/a2,B/b1,M/m1,a2/aend,b1/bend,m1/mend}
            \draw (\src) edge[timeline] (\dest);
        % visibility
        \draw[vis] (a1) to node[above,sloped] {\footnotesize vis} (m1);
        \draw[vis] (b1) to node[above,sloped] {\footnotesize vis} (m1);
        \draw[vis] (m1) to node[above,sloped] {\footnotesize vis} (a2);
    \end{tikzpicture}
    \caption{}\label{fig:wf-example-2}
\end{subfigure}
\caption[Exemples d'une exécutions abstraite mal-formée et d'une exécution abstraite bien-formée]{Exemples d'une exécutions abstraite mal-formée et d'une exécution abstraite bien-formée.
Soit un groupe de pairs composé d'un pair mal-intentionné $p_M$ et de deux pairs honnêtes $p_A$ et $p_B$.
L'exécution abstraite \subref{fig:wf-example-1} n'est pas bien-formée.
L'opération $m_1$ est uniquement observée par un pair mal-intentionné $p_M$.
L'exécution abstraite \subref{fig:wf-example-2} est bien-formée.
L'opération $m_1$ est observée par le pair honnête $p_A$.}\label{fig:wf-example}
\end{figure}

\begin{remark}
Dans la suite de ce manuscrit nous considérons uniquement, sauf explicitement indiqué, des histoires et des exécutions abstraites bien-formées.
Par souci de concision, nous omettons de préciser qu'une histoire ou une exécution abstraite est bien-formée.
\end{remark}

Les pairs mal-intentionnés peuvent faire coïncider dans le temps l'exécution de plusieurs opérations.
La \autoref{fig:no-enum-example} illustre ce scénario.
Pour pouvoir numéroter les opérations des pairs mal-intentionnés, nous utiliserons des exemples dans lesquels les pairs mal-intentionnés exécutent leurs opérations de manière séquentielle.
%Nous suivrons cet ordre pour numéroter les opérations des pairs mal-intentionnés sauf si il gène la compréhension d'un exemple.

\begin{figure}[htb]
\centering
\begin{subfigure}{.5\linewidth}
    \centering
    \begin{tikzpicture}
        % Peers
        \node (M) at (0,0) {$p_M$};
        % Events
        \path (M)
            to +(1,0) coordinate (mfork)
            to +(2,0.3) coordinate (mfork1)
            to +(2,-0.3) coordinate (mfork2)
        ;
        \path (mfork1)
            to +(1,0) node[
                timedevt,minimum width=1.5cm
            ] (m1) {}
            to +(9*0.5,0) coordinate (mfork1end)
        ;
        \path (mfork2)
            to +(1.5,0) node[
                timedevt,minimum width=1.5cm
            ] (m2) {}
            to +(9*0.5,0) coordinate (mfork2end)
        ;
        % Timelines
        \foreach \src/\dest in {M/mfork,mfork/mfork1,mfork1/m1,mfork/mfork2,mfork2/m2,m1/mfork1end,m2/mfork2end}
            \draw[timeline] (\src) to (\dest);
    \end{tikzpicture}
    \caption{}\label{fig:no-enum-example-1}
\end{subfigure}%
\begin{subfigure}{.5\linewidth}
    \centering
    \begin{tikzpicture}
        % Peers
        \node (M) at (0,0) {$p_M$};
        % Events
        \path (M)
            to +(1,0) coordinate (mfork)
            to +(2,0.3) coordinate (mfork1)
            to +(2,-0.3) coordinate (mfork2)
        ;
        \path (mfork1)
            to +(1.5,0) node[] (m1) {$\bullet$}
            to +(9*0.5,0) coordinate (mfork1end)
        ;
        \path (mfork2)
            to +(1.5,0) node[] (m2) {$\bullet$}
            to +(9*0.5,0) coordinate (mfork2end)
        ;
        % Timelines
        \foreach \src/\dest in {M/mfork,mfork/mfork1,mfork1/m1,mfork/mfork2,mfork2/m2,m1/mfork1end,m2/mfork2end}
            \draw[timeline] (\src) to (\dest);
    \end{tikzpicture}
    \caption{}\label{fig:no-enum-example-2}
\end{subfigure}
\caption{Mallory est une collaboratrice mal-intentionnée.
Elle est attachée au pair $p_M$.
\subref{fig:no-enum-example-1} Les exécutions des deux opérations de Mallory coïncident dans le temps.
\subref{fig:no-enum-example-2} Exemple d'une exécution abstraite correspondante.}\label{fig:no-enum-example}
\end{figure}

%L'adaptation présentée nous permet de décrire des exécutions de protocoles qui incluent des pairs mal-intentionnés.

La généralisation du formalisme de~\textcite{burckhardt_eventualconsistency_2014} que nous proposons nous permet de décrire des exécutions qui incluent des pairs mal-intentionnés.
Ces descriptions nous permettent de rendre compte des propriétés de cohérence qu'un protocole garantit en présence de pairs mal-intentionnés.



\subsection{Vivacité et sûreté}\label{subsec:consistency-spec-liveness-safety}

La littérature divise les propriétés de cohérence entre propriétés de sûreté et propriétés de vivacité.
Une propriété de sûreté décrit \enquote{quelque chose de mauvais} qui ne devrait jamais survenir~\autocite{lamport_1977_correctness}.
Elle doit être respectée en tout point de l'exécution d'un protocole.
Il s'agit d'un invariant.
Une propriété de vivacité décrit \enquote{quelque chose de positif} qui devrait survenir~\autocite{lamport_1977_correctness}.
Elle peut être violée en plusieurs points de l'exécution d'un protocole.
Une propriété de cohérence peut être la conjonction d'une propriété de sûreté et d'une propriété de vivacité~\autocite{alpern_liveness_1985}.

Dans ce chapitre nous avons déjà rencontré plusieurs propriétés de sûreté telles que l'\autoref{eq:chat-spec} qui spécifie le fil de discussion.
En revanche, nous n'avons pas rencontré de propriétés de vivacité.
Dans le \autoref{ch:problematic}, l'intégration à terme des modifications est une propriété de vivacité.
Elle stipule qu'une modification est à terme intégrée par tous les pairs.

Parce que les propriétés de vivacité décrivent quelque chose qui devrait survenir, elles nous invitent à penser l'exécution d'un protocole comme une succession infinie d'événements qui se déroule dans le temps.
Une histoire peut décrit les opérations exécutées sur l'intégralité ou une partie d'une exécution.
Elle décrit une partie d'une exécution lorsqu'elle enregistre l'ensembles des opérations exécutées depuis le commencement de l'exécution jusqu'à un temps donnée.
Une histoire peut évoluer vers plusieurs histoires hypothétiques dans lesquelles de nouvelles opérations ont été exécutées.
Par abus de langage nous parlons d'\emph{opérations futures}.
Ces histoires hypothétiques sont des \emph{extensions de l'histoire}.
La \autoref{def:hist-ext} définit formellement l'extension d'une histoire.

\begin{definition}[Extension d'une histoire]\label{def:hist-ext}
Une histoire $H'$ est une extension d'une histoire $H$, et nous écrivons $H' \sqsupset H$, si et seulement si~:
\begin{itemize}
    \item Les opérations de $H$ correspondent à un sous-ensemble fini des opérations de $H'$. $H$ est donc une histoire finie.

    \begin{equation*}
    H \subset H' \land H \textit{est finie}
    \end{equation*}

    \item Si l'opération $y$ est incluse dans $H$, alors toutes les opérations de $H'$ qui retournent-avant $y$ sont également incluses dans $H$.
    \begin{equation*}
    y \in H \land x \rb_{H'} y \implies x \in H
    \end{equation*}
    
    \item Les relations \emph{retourne-avant} sont inchangées.
    \begin{equation*}
    x, y \in H \land x \rb_{H'} y \iff x \rb_{H} y
    \end{equation*}
    
    \item Les caractéristiques des opérations (pair, appel, valeur de retour) sont conservées.
\end{itemize}
\end{definition}

Une propriété de vivacité peut alors être exprimée comme un prédicat qui doit être vérifié dans l'histoire considérée ou dans une ou plusieurs de ses extensions.
Une propriété de vivacité ne peut pas être vérifiée indépendamment des autres propriétés de cohérence considérées.
Seules les extensions de l'histoire qui respectent les autres propriétés de cohérence doivent être considérées.

L'intégration à terme des modifications pourrait ainsi être traduite par~: une opération de modification est à terme visible à une infinité d'opérations d'interrogation.
Nous pouvons prendre avantage de la flexibilité de la relation de visibilité pour simplifier l'expression à~: une opération est à terme visible à une infinité d'opérations.
En d'autres termes, pour toute opération il n'existe pas une infinité d'opérations auxquelles elle n'est pas visible~:

\begin{equation}
    %\forall x \in A\ \exists A_1 \sqsupseteq A\ \forall A_2 \sqsupset A_1, y \in A_2 \sminus A_1 \qsep x \vis y
    \forall x \in A \qsep \set*{y \in A \given x \not\vis y} \textit{est fini}
\end{equation}

% L'intégration à terme des modifications pourrait ainsi être traduite par~: une opération de modification est à terme visible à toute opération future d'interrogation.
% Nous pouvons prendre avantage de la flexibilité de la relation de visibilité pour simplifier l'expression à~: une opération est à terme visible à toute opération future.
% Certaines propriétés de vivacité peuvent être exprimer sans le concept d'extension d'une histoire.
% La propriété d'intégration à terme en fait partie et peut être exprimée comme suit~: pour toute opération il n'existe pas une infinité d'opérations auxquelles elle n'est pas visible.
% Nous la renommons volontiers en propriété de visibilité à terme~:

% Elle pourrait être traduite par la propriété de cohérence suivante~: une opération de modification est à terme visible à toute opération future d'interrogation.
% Nous pouvons prendre avantage de la flexibilité de la relation de visibilité pour simplifier l'expression à~: une opération est à terme visible à toute opération future.
% En d'autres termes, pour toute opération il n'existe pas une infinité d'opérations auxquelles elle n'est pas visible.
% Nous pouvons ainsi définir la propriété d'intégration à terme que nous renommons volontiers en propriété de visibilité à terme~:

% Pour terminer la définition du modèle de cohérence à terme forte, nous définissons également la propriété de sûreté de convergence forte~:

% \begin{equation}
%     \forall x, y \in A \qsep \trm{call}(x) = \trm{call}(y) = \trm{rd} \land \trm{ctx}_A(x) = \trm{ctx}_A(y) \implies \trm{rval}(x) = \trm{rval}(y)
% \end{equation}

% Dans ce manuscrit, la propriété de convergence forte est impliquée par les spécifications de types de données répliquées.
% C'est le cas dans l'\autoref{eq:chat-spec} qui spécifie le fil de discussion.
% Deux opérations de lecture qui ont le même contexte ont nécessairement la même valeur de retour.

% Les propriétés de vivacités ne peuvent pas être vérifiés indépendamment des autres propriétés de sûreté.
% Si une propriété de vivacité est vérifiée dans un futur donné nous devons nous assurer que ce futur vérifie les autres propriétés de sûreté et de vivacité considérées.

% Un protocole garantit une propriété de cohérence si et seulement si chacune des exécutions abstraites qu'il peut engendrer la respecte.
% Nous ne pouvons pas savoir à quel moment une propriété de vivacité sera respectée.
% Par exemple, la propriété d'intégration à terme des effets des opérations ne donne aucune borne sur le temps nécessaire pour la satisfaire.
% Nous ne pouvons donc pas savoir si un protocole vérifie une telle propriété en raisonnant uniquement sur des exécutions finies.
% Nous devons raisonner également sur des exécutions infinies.
% La \autoref{def:abstract-exec} permet la description d'exécutions abstraites infinies.
% En effet, l'ensemble des opérations exécutées est dénombrable, mais peut être non-fini.
% Une exécution abstraite respecte donc une propriété de vivacité si et seulement si il existe une extension qui la respecte.

% Dans le cas d'une propriété de sûreté, il est nécessaire de vérifier que la propriété est respectée en chaque point des exécutions possibles du protocole.
%Chaque point d'une exécution peut être restreint en une exécution abstraite (bien-formée).
%Ces exécutions abstraites correspondent à des préfixes finis de l'exécution abstraite finale.

La classification des propriétés de cohérence en propriétés de vivacité et en propriétés de sûreté permet de mieux apprécier les garanties que représente le respect de telles propriétés.
Les propriétés de cohérences sont généralement réunies au sein de \emph{modèles de cohérence}.

\subsection{Ordre des Modèles de cohérence}\label{subsec:consistency-spec-hier}

Pour apprécier la différence entre deux protocoles de réplication, il suffit d'énumérer l'ensemble des propriétés de cohérence que chacun garantit.
La comparaison de ces ensembles de propriétés de cohérence peut être fastidieux.
C'est pour cette raison que les propriétés de cohérence sont généralement réunies au sein de \emph{modèles de cohérence}.
Un protocole garantit un \emph{modèle de cohérence} si toutes les histoires qu'il peut produire peuvent être justifiées par au moins une \emph{exécution abstraite} qui respecte ce modèle de cohérence.
Par abus de langage nous désignons l'ensemble des exécutions abstraites qui respectent un modèle de cohérence par le nom du modèle de cohérence.
La \autoref{def:consistency-model} introduit cet abus de langage.

\begin{definition}[Modèle de cohérence et exécutions abstraites]\label{def:consistency-model}
Soit un modèle de cohérence $C$.
Nous écrivons $A \in C$ si et seulement si l'exécution abstraite $A$ respecte le modèle de cohérence $C$.
$C$ désigne donc également l'ensemble des exécutions abstraites qui respectent le modèle de cohérence $C$.
\end{definition}

% \begin{definition}[Histoire correcte]\label{def:correct-history}
% Une histoire $H$ vérifie un modèle de cohérence $C$ si et seulement si il existe une exécution abstraite $A \defeq \tuple*{H, \trm{vis}}$ tel que $A$ respecte $C$.
% \begin{equation*}
%     H \textit{is C-correct} \defiff \exists A \defeq \tuple*{H, \_} \qsep A \in C
% \end{equation*}
% \end{definition}

Les modèles de cohérences offrent des garanties variées.
Certains modèles de cohérence permettent des exécutions que d'autres ne permettent pas.
Un modèle de cohérence est dit plus fort qu'un second modèle de cohérence si il accepte un sous-ensemble strict des exécutions abstraites que le premier accepte.
Dans la \autoref{def:consistency-hierearchy}, nous introduisons la notation que nous utilisons pour mettre en évidence qu'un modèle de cohérence est plus fort qu'un autre.
Deux modèles de cohérence sont incompatibles si l'un n'est pas plus fort que l'autre.
Nous pouvons néanmoins juger de la \enquote{force} d'un modèle de cohérence par rapport au nombre d'exécutions abstraites qu'il permet.
L'ensemble des modèles de cohérence est alors partiellement ordonné
~\autocite{viotti_consistency_2016}.

\begin{definition}[Force des modèles de cohérence]\label{def:consistency-hierearchy}
Soit deux modèle de cohérence $C$ et $C'$.
Le modèle de cohérence $C$ est plus fort que le modèle de cohérence $C'$, si et seulement si l'ensemble des exécutions abstraites qui respectent $C$ est strictement inclut dans l'ensemble des exécutions abstraites qui respectent $C'$.
En d'autres termes $C \subset C'$.
\end{definition}

Un modèle de cohérence plus fort permet de limiter le nombre de comportements possibles.
Par conséquent, il permet de raisonner plus facilement lors de la conception et l'utilisation d'un protocole.
La recherche des modèles les plus forts pour un modèle de système donné est un domaine de recherche actif~\cite{mahajan_2011_cac,guerraoui_2016_tradeoffs-replication,viotti_consistency_2016}.
Dans la \autoref{sec:causal-models} nous présentons des modèles de cohérence.


\section{Modèles de cohérence et causalité}\label{sec:causal-models}

Dans cette section nous présentons plusieurs modèles de cohérence.
Nous décrivons d'abord le modèle de cohérence à terme forte qui a été abordé informellement dans le \autoref{ch:problematic}.
Nous décrivons ensuite le modèle de cohérence causale.
Les modèles de cohérence que nous présentons dans la suite de ce manuscrit ne reposent pas directement sur le modèle de cohérence causale.
Cependant, il s'agit d'un classique de la littérature des systèmes distribués.
En outre, sa description nous permet d'illustrer l'utilisation du formalisme présenté dans la \autoref{sec:consistency-spec} et sa compréhension conditionne la compréhension des modèles de cohérence que nous abordons par la suite.
Nous décrivons également le modèle de cohérence \acf{VFJC} sur-lequel nous reposons pour établir la contribution du \autoref{ch:pruned-log}.
Pour faciliter son introduction nous présentons le modèle de cohérence \acf{FJC}.

\subsection{Cohérence à terme forte}\label{subsec:strong-eventual-consistency}

Le modèle de cohérence à terme est le modèle le plus faible qu'un protocole de réplication doit respecter~\autocite{saito_2005_optimisticreplication,burckhardt_eventualconsistency_2014}.
Dans ce manuscrit nous considérons un modèle de cohérence avec une propriété de convergence plus forte.
Il s'agit du modèle de cohérence à terme forte~\autocite{shapiro_2011_crdt,burckhardt_eventualconsistency_2014}.
Nous avons motivé ce choix dans le \autoref{ch:problematic}.
La \autoref{def:strong-eventual-consistency} définit ce modèle.
Elle reprend la propriété de visibilité à terme définit dans la \autoref{subsec:consistency-spec-liveness-safety}.

\begin{definition}[Cohérence à terme forte]\label{def:strong-eventual-consistency}
    Soit une exécution abstraite $A$. $A$ respecte le modèle de cohérence à terme forte si et seulement si~:

    \begin{description}
    \item[\namedlabel{itm:eventual-vis}{EC1} (visibilité à terme)]
    Les effets des opérations de modification sont à terme intégrées par les pairs (honnêtes).
    \begin{equation*}
        \forall x \in A \qsep \set*{y \in A \given x \not\vis y} \textit{est fini}
    \end{equation*}

    \item[\namedlabel{itm:strong-conv}{EC2} (Convergence forte)]
    Les copies des pairs (honnêtes) convergent.
    \begin{equation*}
        \forall x, y \in A \qsep \trm{call}(x) = \trm{call}(y) = \trm{rd} \land \trm{ctx}_A(x) = \trm{ctx}_A(y) \implies \trm{rval}(x) = \trm{rval}(y)
    \end{equation*}
    \end{description}
\end{definition}

Dans ce manuscrit, la propriété de convergence forte est impliquée par les spécifications de types de données répliquées.
C'est le cas dans l'\autoref{eq:chat-spec} qui spécifie le fil de discussion.
Deux opérations de lecture qui ont le même contexte ont nécessairement la même valeur de retour.

L'ensemble des modèles de cohérence que nous abordons dans les sous-sections suivantes sont compatibles avec le modèle de cohérence à terme forte.
Un protocole peut assurer l'un ou plusieurs de ces modèles ainsi que le modèle de cohérence à terme forte.
\textcite{mahajan_2011_cac} a prouvé cette compatibilité.


\subsection{Cohérence causale}\label{subsec:caucal-consistency}

Le modèle de cohérence causale capture les relations de causalités potentielles entre les opérations et garantit que les pairs honnêtes intègrent les effets des opérations en respectant leurs causalités.
Si une opération $x$ cause potentiellement une opération $y$, alors tous les pairs honnêtes intègrent l'effet de $x$ avant l'effet de $y$.
Les pairs honnêtes s'accordent sur l'ordre d'intégration des effets des opérations causalement liées.
Les opérations qui ne sont pas causalement liées sont dites concurrentes.
Les pairs intègrent les opérations concurrentes dans des ordres potentiellement distincts.
%Elles peuvent être intégrées par un pair dans un ordre arbitraire.
Par exemple si $x$ et $y$ sont deux opérations concurrentes et causent toutes deux l'opération $z$, alors un premier pair peut intégrer l'effet de $x$, puis l'effet de $y$, puis l'effet de $z$, et un second pair peut intégrer l'effet de $y$, puis l'effet de $x$, puis l'effet de $z$.
$x$ et $y$ doivent être intégrées avant $z$.

\textcite{lamport_1978_time} a introduit la définition communément acceptée de la causalité potentielle dans le cadre d'un système de passage de messages.
%à travers la relation \emph{arrive-avant} (\emph{happenes-before}).
%Cette relation s'applique sur des événements internes, des événements d'envoi de messages, et des événements de livraison de messages.
%Un événement $x$ \emph{arrive-avant} un événement $y$, si \begin{inlinelist}
%    \item $x$ survient avant $y$ et tous deux surviennent sur le même pair, ou
%    \item $x$ est l'événement d'envoi d'un message $m$, et $y$ est l'événement de livraison de $m$, ou récursivement
%    \item il existe un événement $z$ tel que $x$ arrive-avant $z$ et $z$ arrive-avant $y$
%\end{inlinelist}.
\textcite{hutto_1990_causal} ont par la suite traduit cette notion en propriétés de cohérence.
% sur lesquelles nous nous basons.
Une opération $x$ cause potentiellement une opération $y$ si et seulement si \begin{inlinelist}
    \item $x$ \emph{retourne-avant} $y$ et $x$ a le même auteur que $y$, ou
    \item L'effet de $x$ est intégré par l'auteur de $y$ avant l'exécution de $y$ ($x$ est visible à $y$), ou récursivement
    \item il existe une opération $x'$ tel que $x$ cause potentiellement $x'$ et $x'$ cause potentiellement $y$
\end{inlinelist}.
La causalité potentielle est transitive.

Dans une exécution abstraite qui respecte le modèle de cohérence causale, si une opération $x$ cause potentiellement une opération $y$, alors l'effet de $x$ est intégré avant l'exécution de $y$.
Il s'ensuit que chaque relation de causalité potentielle donne lieu à une relation de visibilité.
La relation de visibilité devient donc transitive.
La transitivité de la relation de visibilité nous permet de définir la relation de \emph{concurrence} et la relation de \emph{précédence immédiate}.
Ces relations simplifient l'expression de propriétés de cohérence que nous aborderons ultérieurement.

% \paragraph{Précédence.}
% La relation de précédence rend compte d'une influence potentielle d'une opération sur une autre.
% Une opération $x$ précède une opération $y$, et nous écrivons $x \pre y$, si \begin{inlinelist}
%     \item $x$ est visible à $y$, ou récursivement
%     \item il existe une opération $z$ tel que $x$ précède $z$ et $z$ précède $y$
% \end{inlinelist}.
% Nous disons également que $y$ succède $x$.
% La relation de précédence correspond à la fermeture transitive de la relation de visibilité.
% Dans la \autoref{fig:vis-example}, $b_1$ est visible à $b_2$, et $b_2$ est visible à $a_2$.
% Par conséquent, $b_1$ précède $a_2$.
% Ce qui signifie que $b_1$ a potentiellement eu une influence sur le résultat de l'opération $a_2$.

% \begin{equation*}
%     x \pre y \defiff x \vis y \lor \exists z \qsep x \pre z \pre y
% \end{equation*}

% \begin{remark}
% Nous supposons que la relation de visibilité est transitive dans les représentations graphiques qui utilisent la relation de précédence.
% Cette hypothèse est importante car la relation de précédence est construite à partir de la relation de visibilité.
% Elle ne permet pas de déduire de manière exhaustive la relation de visibilité.
% La \autoref{fig:vis-vs-pre-1} et la \autoref{fig:vis-vs-pre-2} décrivent la même exécution abstraite.
% \end{remark}

\paragraph{Concurrence.}
Lorsque la relation de visibilité est transitive, nous disons que deux opérations $x$ et $y$ sont concurrentes, et nous écrivons $x \concur y$, si $x$ n'est pas visible à $y$ et $y$ n'est pas visible à $x$.
Dans la \autoref{fig:vis-vs-pre-2}, $a_1$ et $b_1$ sont concurrentes, ainsi que $a_1$ et $b_2$.

\begin{equation*}
    x \concur y \defiff x \not\vis y \land y \not\vis x
\end{equation*}

\paragraph{Précédence immédiate~\autocite{hernandez2003immediate,hernandez2015minimal}.}
Lorsque la relation de visibilité est transitive, une opération $x$, qui est visible à une opération $y$, précède immédiatement $y$, et nous écrivons $x \idr y$, si et seulement si il n'existe pas une opération $z$ tel que $x$ est visible à $z$ et $z$ st visible à $y$.
Nous disons également que $y$ succède immédiatement $y$.
La relation de précédence immédiate correspond à la réduction transitive de la relation de visibilité.

\begin{equation*}
    x \idr y \defiff x \vis y \land \nexists z \qsep x \vis z \vis y
\end{equation*}

\paragraph{} La \autoref{fig:vis-vs-pre-1} montre que la représentation graphique d'une exécution abstraite où la relation de visibilité est transitive peut devenir difficile à appréhender.
Lorsque la relation de visibilité est transitive, nous préférons représenter la relation de précédence immédiate.
La \autoref{fig:vis-vs-pre-1} et la \autoref{fig:vis-vs-pre-2} sont ainsi équivalentes.

% TODO: in following figure, remove a1?
\begin{figure}[tbh]
\centering
\begin{subfigure}{\linewidth}
    \centering
    \begin{tikzpicture}
        \newcommand\hsep{1.5}
        \newcommand\vsep{-1.4}
        % Peers
        \path node (A) {$p_A$}
            to +(0,\vsep) node (B) {$p_B$}
        ;
        % Timeline ends
        \path (9*\hsep,0) coordinate (aend)
            to +(0,\vsep) coordinate (bend)
        ;
        % Events
        \path (A)
            to +(\hsep,0) node[
                label=above:{$\trm{add}(1)$}
            ] (a1) {$a_1$}
            to +(5*\hsep,0) node[
                label=above:{$\trm{rmv}(2)$}
            ] (a2) {$a_2$}
        ;
        \path (B)
            to +(\hsep,0) node[
                label=below:{$\trm{add}(2)$}
            ] (b1) {$b_1$}
            to +(3*\hsep,0) node[
                label=below:{$\trm{add}(3)$}
            ] (b2) {$b_2$}
            to +(8*\hsep,0) node[
                label=below:{$\trm{rd}\set*{1,3}$}
            ] (b3) {$b_3$}
        ;
        % Timelines
        \foreach \src/\dest in {A/a1,B/b1,a2/aend,b3/bend}
            \draw[timeline] (\src) to (\dest);
        % Visibility
        \foreach \src/\dest in {a1/a2,b1/a2,a2/b3}
            \draw[vis] (\src) to node[above,sloped] {\footnotesize vis} (\dest);
        \foreach \src/\dest in {b1/b2,b2/a2,b2/b3}
            \draw[vis] (\src) to node[below,sloped] {\footnotesize vis} (\dest);
        \draw[vis,bend left=35] (a1) to node[above,sloped] {\footnotesize vis} (b3);
        \draw[vis,bend right=30] (b1) to node[below,sloped] {\footnotesize vis} (b3);
    \end{tikzpicture}
    \caption{}\label{fig:vis-vs-pre-1}
\end{subfigure}
\par\medskip
\begin{subfigure}{\linewidth}
    \centering
    \begin{tikzpicture}
        \newcommand\hsep{1.5}
        \newcommand\vsep{-1.4}
        % Peers
        \path node (A) {$p_A$}
            to +(0,\vsep) node (B) {$p_B$}
        ;
        % Timeline ends
        \path (9*\hsep,0) coordinate (aend)
            to +(0,\vsep) coordinate (bend)
        ;
        % Events
        \path (A)
            to +(\hsep,0) node[
                label=above:{$\trm{add}(1)$}
            ] (a1) {$a_1$}
            to +(5*\hsep,0) node[
                label=above:{$\trm{rmv}(2)$}
            ] (a2) {$a_2$}
        ;
        \path (B)
            to +(\hsep,0) node[
                label=below:{$\trm{add}(2)$}
            ] (b1) {$b_1$}
            to +(3*\hsep,0) node[
                label=below:{$\trm{add}(3)$}
            ] (b2) {$b_2$}
            to +(8*\hsep,0) node[
                label=below:{$\trm{rd}\set*{1,3}$}
            ] (b3) {$b_3$}
        ;
        % Timelines
        \foreach \src/\dest in {A/a1,B/b1,b2/b3,a2/aend,b3/bend}
            \draw[timeline] (\src) to (\dest);
        % Precedence
        \foreach \src/\dest in {a1/a2,b1/b2,b2/a2,a2/b3}
            \draw[pre] (\src) to (\dest);
    \end{tikzpicture}
    \caption{}\label{fig:vis-vs-pre-2}
\end{subfigure}
\caption[Exécutions abstraites qui respectent le modèle de cohérence causale]{Exécutions abstraites qui respectent le modèle de cohérence causale.
L'exécution abstraite de la \subref{fig:vis-vs-pre-2} correspond à la réduction transitive de l'exécution abstraite de la \subref{fig:vis-vs-pre-1}.}\label{fig:vis-vs-pre}
\end{figure}

La littérature comptent plusieurs spécifications de la cohérence causale.
Certaines spécifications~\autocite{ahamad_1995_causal} imposent la manière de résoudre les conflits de modification.
Similairement à~\textcite{mahajan_2011_cac}, nous pensons qu'il est préférable de séparer les garanties d'ordre entre les opérations et les garanties concernant la résolution de conflits.
Certaines spécifications~\autocite{burckhardt_eventualconsistency_2014,viotti_consistency_2016} procèdent à cette séparation, mais ajoutent une garantie qui restreint les résultats possibles des opérations de lecture.
Notre \autoref{def:causal-consistency} de la cohérence causale se restreint uniquement à des garanties d'ordre.

\begin{definition}[Cohérence causale non-spéculative~\autocite{mahajan_2011_cac}]\label{def:causal-consistency}
  Soit une exécution abstraite $A$. $A$ respecte le modèle de cohérence causale non-spéculative, et nous écrivons $A \in \trm{Causal}$, si et seulement si~:

  \begin{description}
  \item[\namedlabel{itm:vtns1}{C1} (visibilité transitive)]
  La relation de visibilité est transitive.
  \begin{equation*}
    x \vis y \land y \vis z \implies x \vis z
  \end{equation*}

  \item[\namedlabel{itm:vtns2}{C2} (visibilité non-spéculative)]
  Une opération future ne peut être visible à une opération passée.
  \begin{equation*}
    y \not\rb x \implies y \not\vis x
  \end{equation*}

  \item[\namedlabel{itm:peer-linear}{C3} (ordre linéaire pour chaque pair)]
  Les opérations d'un même pair sont ordonnées par la relation de visibilité.
  \begin{equation*}
    x, y \in A \land \trm{peer}(x) = \trm{peer}(y) \implies
    (x \vis y \lor y \vis x)
  \end{equation*}
  \end{description}
\end{definition}

Notre définition exclut les visibilités spéculatives.
En d'autres termes, un pair ne peut pas observer une opération qui n'a pas encore été exécutée.
Il ne peut donc pas spéculer sur les opérations qui seront éventuellement exécutées dans le futur.
Cette garantie est nécessaire pour construire certaines propriétés.
Nous parlons ainsi de cohérence causale non-spéculative~\footnote{\textcite{mahajan_2011_cac} parlent de \emph{cohérence causale naturelle}.~\textcite{viotti_consistency_2016} parlent de cohérence causale temps réel.}~\autocite{mahajan_2011_cac,viotti_consistency_2016}.
En dehors de cette section, par abus de langage, nous parlerons de cohérence causale.

\begin{proposition}\label{th:rb-vis}
Dans une exécution abstraite $A$ qui respecte le modèle de cohérence causale, la relation de visibilité est égale à la relation retourne-avant pour les opérations d'un même pair.
\begin{equation*}
    A \in \trm{Causal} \land x, y \in A \land \trm{peer}(x) = \trm{peer}(y) \implies (x \rb y \iff x \vis y)
\end{equation*}
\end{proposition}

\begin{proof}
La \autoref{th:rb-vis} est décomposable en deux implications.

Procédons par contradiction.
Soit une exécution abstraite $A$ et deux opérations $x$ et $y$ d'un même pair $p$ tel que $x$ retourne-avant $y$.
Supposons que $x$ n'est pas visible à $y$.
$y$ est visible à $x$, ou elles n'ont pas de relation de visibilité entre elles.
Le premier cas contredit la propriété~\ref{itm:vtns2} de visibilité non-spéculative.
Le deuxième cas contredit la propriété~\ref{itm:peer-linear} qui assure une visibilité linéaire pour chaque pair.

La deuxième implication est naturellement déduite de la propriété~\ref{itm:vtns2}.
\end{proof}

% \textcite{mahajan_2011_cac} ont montré qu'un protocole toujours-disponible et à convergence unidirectionnelle peut garantir la cohérence causale non-spéculative en l'absence de pairs mal-intentionnés.

Un protocole peut garantir la cohérence causale avec divers mécanismes~\autocite{lamport_1978_time,fidge_1987_timestamps,prakash_1997_barrierbarrier}.
Un protocole naïf pourrait~:

\begin{itemize}
    \item Inclure dans chaque opération $x$ l'ensemble des opérations dont les effets ont été intégrées par l'auteur de $x$ avant l'exécution de $x$.
    Cet ensemble correspond au contexte de l'opération.
    \item Intégrer l'effet d'une opération après l'intégration des effets de l'ensemble des opérations présentes dans son contexte.
\end{itemize}


\subsection{Cohérence \emph{\acl{FJC}}}

% TODO: revoir avec le lien avec la section sur la cohérence causale

Le modèle de cohérence causale offre des garanties qui facilitent l'implémentation de fonctionnalités dans les applications distribuées.
De ce fait, le modèle de cohérence causale est souvent supposé dans les systèmes distribués~\autocite{shapiro_2011_crdt}.
Malheureusement, les pairs mal-intentionnés peuvent compromettre les garanties du modèle de cohérence causale.
%Les pairs mal-intentionnés peuvent exposer des  comportements pour compromettre les propriétés de cohérence qu'un protocole est censé garantir aux pairs honnêtes.
Un pair mal-intentionné peut en particulier produire une équivoque.
Pour ce faire, il présente des opérations distinctes comme étant sa n-ème opération à des pairs différents.
Par exemple, dans la \autoref{fig:causal-violation} le pair mal-intentionné $p_M$ prétend au pair $p_B$ que sa deuxième opération est $m_3$, alors qu'il prétend au pair $p_A$ que sa deuxième opération est $m_2$.
$p_A$ lit ainsi les messages textuels $t_1$ et $t_2$, alors que $p_B$ lit les messages textuels $t_1$ et $t_3$.
L'histoire de la \autoref{fig:causal-violation} ne peut pas à la fois respecter le modèle de cohérence causale et la spécification du fil de discussion formulée dans l'\autoref{eq:chat-spec}.
L'exécution abstraite de la \autoref{fig:causal-violation} respecte la spécification du fil de discussion et viole donc le modèle de cohérence causale.

L'exécution abstraite de la \autoref{fig:causal-violation} ne peut pas respecter le modèle de cohérence causale car $m_2$ ne peut pas être visible à $b_1$ sans violer la cohérence du contenu répliqué.
L'exécution abstraite viole la propriété~\ref{itm:peer-linear} de visibilité linéaire par pair~: $m_2$ n'est pas visible à $m_3$.
Il est démontrable que dans un environnement mal-intentionné, l'une des trois propriétés de la cohérence causale doit être violée pour pouvoir respecter les deux autres~\autocite{mahajan_2011_cac}.

\begin{figure}[htb]
\centering
\begin{subfigure}{\linewidth}
    \centering
    \begin{tikzpicture}
        \newcommand\hsep{1.5}
        \newcommand\vsep{-1.5}
        % Peers
        \path node (A) {$p_A$}
            to +(0,\vsep) node (M) {$p_M$}
            to +(0,2*\vsep) node (B) {$p_B$}
        ;
        % Timeline ends
        \path (9*\hsep,0) coordinate (aend)
            to +(0,\vsep) coordinate (mend)
            to +(0,2*\vsep) coordinate (bend)
        ;
        % Events
        \path (A)
            to +(5*\hsep,0) node[
                label={above:$\trm{rd}\set*{t_1, t_2}$}
            ] (a1) {$a_1$}
            to +(7*\hsep,0) node[
                label={above:$\trm{rd}\set*{t_1, t_2, t_3}$}
            ] (a2) {$a_2$}
        ;
        \path (M)
            to +(\hsep,0) node[
                label={above:$\trm{post}(t_1)$}
            ] (m1) {$m_1$}
            to +(3*\hsep,0) node[
                label={above:$\trm{post}(t_2)$}
            ] (m2) {$m_2$}
            to +(5*\hsep,0) node[
                label={above:$\trm{post}(t_3)$}
            ] (m3) {$m_3$}
        ;
        \path (B)
            to +(6*\hsep,0) node[
                label={below:$\trm{rd}\set*{t_1,t_3}$}
            ] (b1) {$b_1$}
        ;
        % Timelines
        \foreach \src/\dest in {A/a1,a1/a2,a2/aend,M/m1,m1/m2,m2/m3,m3/mend,B/b1,b1/bend}
            \draw (\src) edge[timeline] (\dest);
    \end{tikzpicture}
    \caption{Histoire}
\end{subfigure}
\par\medskip
\begin{subfigure}{\linewidth}
    \centering
    \begin{tikzpicture}
        \newcommand\hsep{1.5}
        \newcommand\vsep{-1.5}
        % Peers
        \path node (A) {$p_A$}
            to +(0,\vsep) node (M) {$p_M$}
            to +(0,2*\vsep) node (B) {$p_B$}
        ;
        % Timeline ends
        \path (9*\hsep,0) coordinate (aend)
            to +(0,\vsep) coordinate (mend)
            to +(0,2*\vsep) coordinate (bend)
        ;
        % Events
        \path (A)
            to +(5*\hsep,0) node[
                label={above:$\trm{rd}\set*{t_1, t_2}$}
            ] (a1) {$a_1$}
            to +(7*\hsep,0) node[
                label={above:$\trm{rd}\set*{t_1, t_2, t_3}$}
            ] (a2) {$a_2$}
        ;
        \path (M)
            to +(\hsep,0) node[
                label={above:$\trm{post}(t_1)$}
            ] (m1) {$m_1$}
            to +(3*\hsep,0) node[
                label={above:$\trm{post}(t_2)$}
            ] (m2) {$m_2$}
            to +(5*\hsep,0) node[
                label={above:$\trm{post}(t_3)$}
            ] (m3) {$m_3$}
        ;
        \path (B)
            to +(6*\hsep,0) node[
                label={below:$\trm{rd}\set*{t_1,t_3}$}
            ] (b1) {$b_1$}
        ;
        % Timelines
        \foreach \src/\dest in {A/a1,M/m1,B/b1,a2/aend,m2/m3,m3/mend,b1/bend}
            \draw[timeline] (\src) to (\dest);
        % Precedence
        \foreach \src/\dest in {m1/m2,m2/a1,m3/b1,a1/a2,b1/a2}
            \draw[pre] (\src) to (\dest);
        \draw[pre,bend right=20] (m1) to (m3);
    \end{tikzpicture}
    \caption{Une exécution abstraite qui respecte la spécification du fil de discussion.}
\end{subfigure}
\caption[Exemple de violation du modèle de cohérence causale]{Exemple d'équivoque.
Les pairs $p_A$, $p_B$, et $p_M$ répliquent un fil de discussion.
$p_M$ est un pair mal-intentionné.
Il prétend au pair $p_A$ que sa deuxième opération est $m_2$, alors qu'il prétend au pair $p_B$ que sa deuxième opération est $m_3$.}\label{fig:causal-violation}
\end{figure}

Le modèle de cohérence~\acf{FJC}~\autocite{mahajan_2011_cac,mahajan_astro_2008} propose d'affaiblir la propriété~\ref{itm:peer-linear} pour tolérer la présence de pairs mal-intentionnés.
Cette dernière est restreinte aux pairs honnêtes.
L'exécution abstraite de la \autoref{fig:causal-violation} respecte ainsi le modèle de cohérence~\ac{FJC}.
La \autoref{def:fjc-consistency} définit formellement le modèle de cohérence~\ac{FJC}.

\begin{definition}[Cohérence \emph{\acl{FJC}} non-spéculative~\autocite{mahajan_2011_cac}]\label{def:fjc-consistency}
  Soit une exécution abstraite bien-formée $A$. $A$ respecte le modèle de cohérence \emph{\acf{FJC}} non-spéculative, et nous écrivons $A \in \trm{FJC}$, si et seulement si~:

  \begin{description}
  \item[\namedlabel{itm:vis-trans}{C1} (visibilité transitive)]
  La relation de visibilité est transitive.
  \begin{equation*}
    x \vis y \land y \vis z \implies x \vis z
  \end{equation*}

  \item[\namedlabel{itm:vis-non-specul}{C2} (visibilité non-spéculative)]
  Une opération ne peut être visible à une opération qui a été exécutée avant.
  \begin{equation*}
    y \not\rb x \implies y \not\vis x
  \end{equation*}

  \item[\namedlabel{itm:honest-linear}{FJC1} (ordre linéaire pour chaque pair honnête)]
  Les opérations d'un même pair honnête sont ordonnées par la relation de visibilité.
  \begin{equation*}
    \forall x, y \in A \qsep (\trm{peer}(x) = \trm{peer}(y) \land \trm{peer}(x) \in \trm{Honest}) \implies (x \vis y \lor y \vis x)
  \end{equation*}
  \end{description}
\end{definition}

Lorsque deux opérations d'un pair mal-intentionné ne sont pas linéairement ordonnées par la relation de visibilité, nous parlons d'opérations \emph{non-linéaires}\footnote{\textcite{mahajan_2011_cac} parlent d'opérations \emph{non-sérialisées} (\emph{non-serial operations})}.
Les opérations non-linéaires forment des \emph{embranchements} (\emph{forks})~\autocite{li_2004_sundr}.
Dans l'exemple présenté, $m_2$ et $m_3$ sont deux opérations non-linéaires. Elles forment deux embranchements~: $m_1 \pre m_2 \pre a_1$ et $m_1 \pre m_3 \pre b_1$.

Pour assurer la convergence des pairs honnêtes, les opérations observées par un pair honnête doivent à terme être observées par chaque pair honnête.
Par conséquent les embranchements doivent être joints.
Les opérations non-linéaires sont donc acceptées par les pairs honnêtes.
Seuls les pairs honnêtes ordonnent linéairement leurs opérations.
Dans la \autoref{fig:causal-violation}, le pair $p_A$ joints les deux embranchements avec l'opération $a_2$.

\begin{proposition}\label{th:honest-rb-vis}
Dans une exécution abstraite $A$ qui respecte le modèle de cohérence \ac{FJC}, la relation de visibilité est égale à la relation retourne-avant pour les opérations d'un même pair honnête.
\begin{equation*}
    \forall x, y \in A \qsep (\trm{peer}(x) = \trm{peer}(y) \land \trm{peer}(x) \in \trm{Honest}) \implies (x \rb y \iff x \vis y)
\end{equation*}
\end{proposition}

La preuve de la \autoref{th:honest-rb-vis} suit la même structure que la preuve de la \autoref{th:rb-vis}.
\enquote{pair} doit être remplacé par \enquote{pair honnête} et~\ref{itm:peer-linear} par~\ref{itm:honest-linear}.

\begin{proposition}\label{th:causal-fjc}
Soit une exécution abstraite qui respecte le modèle de cohérence \ac{FJC}.
Si tous les pairs sont honnêtes, alors l'exécution abstraite respecte également le modèle de cohérence causale.
\begin{equation*}\begin{split}
    \forall A \in \trm{FJC} \qsep \trm{Peers} = \trm{Honest} \implies A \in \trm{Causal}
\end{split}\end{equation*}
\end{proposition}

\begin{proof}
Si tous les pairs sont honnêtes alors les propriétés~\ref{itm:peer-linear} et~\ref{itm:honest-linear} sont équivalentes.
\end{proof}

le modèle de cohérence \ac{FJC} est plus faible que le modèle de cohérence causale.
Les deux modèles partagent les mêmes garanties à l'exception de~\ref{itm:peer-linear} qui est une spécialisation de~\ref{itm:honest-linear}.
Toutes les exécutions qui respectent le modèle de cohérence causale respectent également le modèle de cohérence~\ac{FJC}.
Une application qui se base sur le modèle de cohérence~\ac{FJC} doit gérer la complexité induite par l'acceptation d'opérations \emph{non-linéaires}, c'est-à-dire d'opérations concurrentes d'un même pair.
Il est toutefois possible de présenter une exécution \ac{FJC} comme une exécution causale en assignant des pairs virtuels aux opérations \emph{non-linéaires}~\autocite{mahajan_depot_2011}.
Ainsi, l'application considère que deux opérations non-linéaires n'ont pas été exécutées par le même pair.


\subsection{Cohérence \emph{\acl{VFJC}}}

Les pairs mal-intentionnés peuvent réaliser des équivoques.
Dans une exécution abstraite, ces équivoques se traduisent par des opérations non-linéaires.
Une opération est non-linéaire si il existe une opération du même auteur qui lui est concurrente.
Chaque opération non-linéaire forme un embranchement.
Pour préserver la convergence des copies, le modèle de cohérence~\acf{VFJC}~\autocite{mahajan_2011_cac} permet aux pairs d'accepter des opérations non-linéaires.
Les pairs peuvent ainsi joindre des embranchements.

Pour certains contenus répliqués, les équivoques peuvent produire des conflits de modification difficiles à identifier et à résoudre.
%Leur résolution peut notamment produire un sur-coût [Depot?].
De ce fait, il est souhaitable d'empêcher à terme la réalisation de nouvelles équivoques.
Pour ce faire, les pairs qui en produisent doivent être à terme évincés.
Leurs opérations futures devraient donc à terme être rejetées.

De manière optimiste, un pair honnête présume que les autres pairs sont honnêtes tant qu'ils ne produisent pas d'équivoques.
Un pair reconnaît qu'un pair est mal-intentionné dès lors qu'il observe deux opérations non-linéaires de ce dernier.
Cette observation se traduit par une jonction d'embranchements.
Dans l'exécution abstraite $A_1$ de la \autoref{fig:provably-malicious}, le pair $p_A$ observe les opérations non-linéaires $m_2$ et $m_3$ du pair $p_M$. $p_A \in \trm{obs}_{A_1}(m_2) \cap \trm{obs}_{A_1}(m_3)$.
Il reconnaît ainsi $p_M$ comme mal-intentionné.
Le pair $p_B$ n'a pas encore observé $m_2$. Il présume que $m_3$ est une opération linéaire, et donc que $p_M$ est honnête.

\begin{figure}[htb]
\centering
\begin{tikzpicture}
    \newcommand\hsep{1.5}
    \newcommand\vsep{-1.5}
    % Peers
    \path node (A) {$p_A$}
        to +(0,\vsep) node (M) {$p_M$}
        to +(0,2*\vsep) node (B) {$p_B$}
    ;
    % Timeline ends
    \path (10*\hsep,0) coordinate (aend)
        to +(0,\vsep) coordinate (mend)
        to +(0,2*\vsep) coordinate (bend)
    ;
    % Events
    \path (A)
        to +(3*\hsep,0) node[] (a1) {$a_1$}
        to +(5*\hsep,0) node[] (a2) {$a_2$}
        to +(8*\hsep,0) node[] (a3) {$a_3$}
    ;
    \path (M)
        to +(\hsep,0) node[] (m1) {$m_1$}
        to +(2*\hsep,0) node[] (m2) {$m_2$}
        to +(3*\hsep,0) node[] (m3) {$m_3$}
        to +(6*\hsep,0) node[] (m4) {$m_4$}
    ;
    \path (B)
        to +(4*\hsep,0) node[] (b1) {$b_1$}
        to +(7*\hsep,0) node[] (b2) {$b_2$}
        to +(9*\hsep,0) node[] (b3) {$b_3$}
    ;
    % Prefix
    \node[draw, dashed, label=below:$A_1$, fit=(a2) (B)]{};
    % Timelines
    \foreach \src/\dest in {A/a1,M/m1,B/b1,a3/aend,m2/m3,m4/mend,b2/b3,b3/bend}
        \draw[timeline] (\src) to (\dest);
    % Precedence
    \foreach \src/\dest in {m2/a1,m3/b1,b1/a2,m4/b2,b2/a3,a3/b3}
        \draw[pre] (\src) to (\dest);
    \fill[fill=white] (intersection of m3--m4 and b1--a2) circle (3pt);
    \foreach \src/\dest in {a1/a2,a2/a3,m1/m2,m3/m4,b1/b2}
        \draw[pre] (\src) to (\dest);
    \draw[pre,bend right=20] (m1) to (m3);
\end{tikzpicture}
\caption{Exemple d'exécutions abstraites qui respectent le modèle de cohérence \ac{VFJC}.}\label{fig:provably-malicious}
\end{figure}

%\begin{definition}[Reconnus mal-intentionnés]\label{def:known-malicious}
%  Soit une exécution abstraite $A$ qui respecte le modèle de cohérence \acl{FJC}.
%  Les pairs reconnus mal-intentionnés correspondent à ceux qui ont exécuté au moins deux opérations non-linéaires dans $A$.
%  \begin{equation*}
%      \trm{KnownMalicious}_A \defeq \set*{p \given \exists y, z \in A \qsep y \concur z \land p = \trm{peer}(y) = \trm{peer}(z)}
%  \end{equation*}
%\end{definition}
%
%La \autoref{def:restrict-abs-exec} introduit la notation utilisée pour dénoter la restriction d'une exécution abstraite à une opération et les opérations qui sont visibles à cette dernière.
%
%\begin{definition}[Exécution abstraite restreinte à un préfixe de visibilité]\label{def:restrict-abs-exec}
%  Soit une opération $y$ d'une exécution abstraite $A$.
%  Nous notons $A(y)$ l'exécution abstraite restreinte à $y$ et aux opérations qui lui sont visibles.
%  \begin{equation*}
%      A(y) \defeq A \cap \set*{x \in A \given x \viseq y}
%  \end{equation*}
%\end{definition}

Pour faciliter la spécification du modèle de cohérence \ac{VFJC}, nous définissons dans la \autoref{def:known-malicious} l'ensemble des pairs reconnus mal-intentionné en une opération.
La \autoref{tab:known-malicious} indique pour chaque opération de la \autoref{fig:provably-malicious} les pairs qui sont reconnus mal-intentionnés.

\begin{definition}[Reconnus mal-intentionnés]\label{def:known-malicious}
  Soit une opération $x$ d'une exécution abstraite $A$ qui respecte le modèle de cohérence \acl{FJC}.
  Les pairs reconnus mal-intentionnés en $x$ correspondent à ceux qui ont exécuté au moins deux opérations non-linéaires qui sont visibles à $x$.
  \begin{equation*}
      \trm{knownMalicious}_A(x) \defeq \set*{p \given \exists y, z \qsep y \pre x \land z \pre x \land y \concur z \land p = \trm{peer}(y) = \trm{peer}(z)}
  \end{equation*}
\end{definition}

\begin{table}[htb]
    \centering
    \begin{tabular}{cc}
        Opération & $\trm{knownMalicious}_A$ \\
        \toprule
        $a_1$ & $\emptyset$ \\
        $a_2$ & $\set*{p_M}$ \\
        $a_3$ & $\set*{p_M}$ \\
        $m_1$ & $\emptyset$ \\
        $m_2$ & $\emptyset$ \\
        $m_3$ & $\emptyset$ \\
        $m_4$ & $\emptyset$ \\
        $b_1$ & $\emptyset$ \\
        $b_2$ & $\emptyset$ \\
        $b_3$ & $\set*{p_M}$ \\
    \end{tabular}
    \caption{Pairs reconnus mal-intentionnés dans l'exécution abstraite de la \autoref{fig:provably-malicious} par le pair qui exécute l'opération considérée.}\label{tab:known-malicious}
\end{table}

L'éviction d'un pair reconnu mal-intentionné ne doit pas menacer la convergence des copies des pairs honnêtes.
Dans l'exécution abstraite $A_1$ de la \autoref{fig:provably-malicious}, $p_A$ reconnaît $p_M$ comme mal-intentionné.
Cependant, $p_A$ ne peut pas systématiquement rejeter les opérations de $p_M$ sans compromettre la convergence des copies des pairs honnêtes.
En effet, le pair $p_B$ présume encore $p_M$ comme honnête.
Il peut donc encore accepter des opérations futures de $p_M$.
Dans l'exécution abstraite $A$ de la \autoref{fig:provably-malicious}, $p_B$ accepte ainsi $m_4$.
Bien que $p_A$ reconnaît que $p_M$ est mal-intentionné, il doit accepter $m_4$ pour ne pas compromettre la convergence de sa copie avec celle de $p_B$.
Nous disons que $p_A$ a indirectement accepté $m_4$.

Un pair honnête peut rejeter les opérations d'un pair qu'il reconnaît mal-intentionné si ces dernières ne sont par acceptées par un autre pair.
$p_A$ devrait rejeter $m_4$ tant qu'elle n'est pas acceptée par $p_B$.
Dans l'exemple de la \autoref{fig:provably-malicious}, le pair $p_M$ est évincé une fois que $p_A$ et $p_B$ le reconnaissent tous deux comme mal-intentionné.

En présence d'autres pairs mal-intentionnés, il ne suffit pas que les pairs reconnaissent un pair comme mal-intentionné pour l'évincer du groupe.
Un pair mal-intentionné peut reconnaître un autre pair comme mal-intentionné et continuer à accepter ses opérations.
Dans l'exécution abstraite $A_1$ de la \autoref{fig:known-colluding-malicious}, les pairs $p_A$ et $p_O$ reconnaissent que $p_M$ est mal-intentionné.
Dans l'exécution abstraite $A$ de la \autoref{fig:known-colluding-malicious}, $p_O$ accepte $m_4$ alors qu'il a précédemment reconnu que son auteur est mal-intentionné.

\begin{figure}[htb]
\centering
\begin{tikzpicture}
    \newcommand\hsep{1.5}
    \newcommand\vsep{-1.5}
    % Peers
    \path node (A) {$p_A$}
        to +(0,\vsep) node (M) {$p_M$}
        to +(0,2*\vsep) node (O) {$p_O$}
    ;
    % Timeline ends
    \path (10*\hsep,0) coordinate (aend)
        to +(0,\vsep) coordinate (mend)
        to +(0,2*\vsep) coordinate (oend)
    ;
    % Events
    \path (A)
        to +(3*\hsep,0) node[] (a1) {$a_1$}
        to +(6*\hsep,0) node[] (a2) {$a_2$}
        to +(9*\hsep,0) node[] (a3) {$a_3$}
    ;
    \path (M)
        to +(\hsep,0) node[] (m1) {$m_1$}
        to +(2*\hsep,0) node[] (m2) {$m_2$}
        to +(3*\hsep,0) node[] (m3) {$m_3$}
        to +(7*\hsep,0) node[] (m4) {$m_4$}
    ;
    \path (O)
        to +(4*\hsep,0) node[] (o1) {$o_1$}
        to +(5*\hsep,0) node[] (o2) {$o_2$}
        to +(8*\hsep,0) node[] (o3) {$o_3$}
    ;
    % Prefix
    \node[draw, dashed, label=below:$A_1$, fit=(a2) (O)]{};
    % Timelines
    \foreach \src/\dest in {A/a1,M/m1,O/o1,a1/a2,a3/aend,m2/m3,m4/mend,o3/bend}
        \draw[timeline] (\src) to (\dest);
    % Precedence
    \foreach \src/\dest in {m2/a1,m3/o1,a1/o2,o2/a2,m4/o3,o3/a3}
        \draw[pre] (\src) to (\dest);
    \fill[fill=white] (intersection of m3--m4 and a1--o2) circle (3pt);
    \fill[fill=white] (intersection of m3--m4 and o2--a2) circle (3pt);
    \foreach \src/\dest in {a2/a3,m1/m2,m3/m4,o1/o2,o2/o3}
        \draw[pre] (\src) to (\dest);
    \draw[pre,bend right=20] (m1) to (m3);
\end{tikzpicture}
\caption{Exemple d'une exécution abstraite qui ne respecte pas le modèle de cohérence \ac{VFJC}.
L'exécution abstraite $A_1$ respecte le modèle de cohérence \ac{VFJC}.}\label{fig:known-colluding-malicious}
\end{figure}

Les pairs honnêtes doivent s'assurer qu'un pair qui reconnaît un autre pair comme mal-intentionné arrête d'accepter directement les opérations de ce dernier.
En d'autres termes, reconnaître qu'un pair est mal-intentionné devrait être responsabilisant.
Ainsi un pair honnête ou mal-intentionné ne peut exécuter une opération qui succède immédiatement l'opération d'un pair qu'il reconnaît comme mal-intentionné.
Il s'agit de la propriété~\ref{itm:vfjc2} du modèle de cohérence \acf{VFJC} que nous présentons dans la \autoref{def:vfjc-consistency}.

\begin{definition}[Cohérence \emph{\acl{VFJC}}~\autocite{mahajan_2011_cac}]\label{def:vfjc-consistency}
  Soit une exécution abstraite $A$. $A$ respecte le modèle de cohérence \emph{\acf{VFJC}}, et nous écrivons $A \in \trm{VFJC}$, si et seulement si~:

  \begin{description}
  \item[\namedlabel{itm:vfjc1}{VFJC1} (cohérence \emph{\acl{FJC}})]
  L'exécution abstraite $A$ respecte le modèle de cohérence \emph{\ac{FJC}}.
  \begin{equation*}
    A \in \trm{\acs{FJC}}
  \end{equation*}

  \item[\namedlabel{itm:vfjc2}{VFJC2} (partage avec les pairs présumés honnêtes)]
  Si une opération $x$ précède immédiatement une opération $y$, alors aucune des deux opérations n'est exécutée par un pair qui est reconnu mal-intentionné en $y$.
  \begin{equation*}
    x \idr y \implies \trm{peer}(x), \trm{peer}(y) \notin \trm{knownMalicious}_A(y)
  \end{equation*}
  % Cette dernière propriété peut être affaiblie, en supprimant la condition que l'auteur de y ne doit pas être reconnu mal-intentionné.
  % Cet affaiblissement est possible à cause de WF2
  % En effet, un pair honnête doit observer l'opération de y si son auteur est mal-intentionné.
  % si l'auteur de y est reconnu mal-intentionné alors il est mal-intentionné.
  % Dans ce cas la propriété VFJC2 ne peut pas tenir
  \end{description}
\end{definition}

Par l'éviction systématique des pairs mal-intentionnés, le modèle de cohérence \ac{VFJC} borne le nombre d'embranchements acceptés par les pairs honnêtes.
Il accepte uniquement les embranchements qui ne peuvent pas être évités sans compromettre la convergence des copies des pairs.
Le nombre maximal d'embranchements acceptés est fonction du nombre de pairs honnêtes et du nombre de pairs mal-intentionnés.

Le modèle de cohérence~\ac{VFJC} est plus faible que le modèle de cohérence causale.
Il est toutefois plus fort que le modèle de cohérence~\ac{FJC} puisqu'il n'accepte qu'un sous-ensemble des embranchements que les pairs mal-intentionnés peuvent créer.

% La \autoref{fig:causal-fjc-vfjc-order} compare la force de ces trois modèles.

% \begin{figure}[htb]
% \centering
% \begin{tikzpicture}
%     \node at (90:-0.3) {Causal};
%     \node at (90:0.6cm) {VFJC};
%     \node at (90:1.5cm) {FJC};

%     \draw (0,0) ellipse (4cm and 1.8cm);
%     \draw (0,-0.3) ellipse (3cm and 1.2cm);
%     \draw (0,-0.6) ellipse (2cm and 0.6cm);
% \end{tikzpicture}
% \caption{Comparaison de la force des modèles de cohérence présentés;
% Chaque cercle correspond à l'ensemble des exécutions abstraites acceptées par le modèle de cohérence.}\label{fig:causal-fjc-vfjc-order}
% \end{figure}

\clearpage % better layout
\section{Types de données répliquées}\label{sec:crdt}

La réplication optimiste~\autocite{saito_2005_optimisticreplication} d'un contenu partagé permet d'interroger et de modifier ce dernier à tout moment.
Pour ce faire, chaque pair détient sa propre copie du contenu partagé sur-laquelle il exécute ses opérations de modification et ses opérations d'interrogation.
Un pair intègre ses modifications avant de les transmettre ultérieurement aux autres pairs qui les intègrent à leur tour.
La modification parallèle des copies conduit nécessairement à leur divergence~\autocite{dourish_1995_divergence}.
Les protocoles de réplication optimiste sont responsables de la convergence à terme des copies et plus largement du maintien de la cohérence des copies.
Le maintien de la cohérence des copies doit préserver autant que possible l'intention des opérations exécutées.

La conception d'un protocole de réplication n'est pas une tâche aisée~\autocite{oster2005_otisuues}.
Il doit prendre en compte les aléas du réseau \autocite{rotem_falalcies_2006} et résoudre les éventuels conflits engendrés par des modifications parallèles et incompatibles.
Dans la \autoref{fig:set-conflict-example}, les pairs $p_A$ et $p_B$ modifient un ensemble répliqué d'entiers.
Alors que $p_B$ ajoute puis supprime un entier dans l'ensemble, le pair $p_A$ ajoute en parallèle ce même entier dans l'ensemble.
$p_B$ a l'intention de supprimer l'entier de l'ensemble, alors que $p_A$ a l'intention de l'ajouter à l'ensemble.
Il est autant correct que l'ensemble contienne ou ne contienne pas cet entier.
La suppression et l'ajout en parallèle d'une même valeur dans un ensemble répliqué sont deux opérations incompatibles.


\begin{figure}[htb]
\centering
\begin{tikzpicture}
    \newcommand\hsep{1.4}
    \newcommand\vsep{-1.2}
    % Peers
    \path node (A) {$p_A$}
        to +(0,1*\vsep) node (B) {$p_B$}
    ;
    % Timeline ends
    \path (5*\hsep,0) coordinate (aend)
        to +(0,1*\vsep) coordinate (bend)
    ;
    % Events
    \path (A)
        to +(2*\hsep,0) node[
            label={above:$\trm{add}(1)$}
        ] (a1) {$a_1$}
        to +(4*\hsep,0) node[
            label={above:$\trm{rd} ?$}
        ] (a2) {$a_2$}
    ;
    \path (B)
        to +(1*\hsep,0) node[
            label={below:$\trm{add}(1)$}
        ] (b1) {$b_1$}
        to +(3*\hsep,0) node[
            label={below:$\trm{rmv}(1)$}
        ] (b2) {$b_2$}
    ;
    % Timelines
    \foreach \src/\dest in {A/a1,a2/aend,B/b1,b2/bend}
        \draw (\src) edge[timeline] (\dest);
    % Precedence
    \foreach \src/\dest in {a1/a2,b1/b2,b2/a2}
        \draw[pre] (\src) to (\dest);
\end{tikzpicture}
\caption[Exécution en parallèle d'opérations incompatibles]{Exemple d'exécutions en parallèle d'opérations incompatibles.
L'exécution abstraite respecte le modèle de cohérence causale.}\label{fig:set-conflict-example}
\end{figure}

Les \acfp{CRDT}~\autocite{shapiro_2011_crdt,roh_2011_rga} sont des types de données conçus pour être répliqués et modifiés en parallèle par un ensemble de pairs.
Ils encapsulent la complexité des protocoles de réplication optimiste derrière une interface bien définie.
Les concepteur·ice·s d'applications peuvent ainsi se concentrer sur la sémantique des contenus répliqués.
Nous spécifions un \ac{CRDT} avec deux modèles~\autocite{preguia2018_crdt}~: un type abstrait de données répliquées et un schéma de synchronisation.
Le type abstrait de données répliquées définit les opérations qui peuvent être exécutées et leur effet lorsqu'elles sont exécutées en parallèle ou en séquence.
Nous abordons ce sujet plus en détail dans la \autoref{sec:crdt-spec}.
Le schéma de synchronisation conditionne la manière dont les copies d'un \ac{CRDT} peuvent se synchroniser.
Il repose lui-même sur un modèle réseau.
Nous détaillons cet aspect dans la \autoref{sec:crdt-sync}.

\subsection{Type abstrait de données répliquées}\label{sec:crdt-spec}

Pour modifier et consulter un contenu, un pair exécute respectivement des opérations de modification et des opérations d'interrogations.
L'exécution des opérations d'interrogations ne modifient pas le contenu.
En d'autres termes, leur exécution ou l'absence de leur exécution ne change pas le résultat des interrogations ultérieures.
Les opérations qui peuvent être exécutées sur un contenu dépendent du type du contenu.
Un type abstrait de données définit les opérations qui peuvent être exécutées sur un ensemble de types de données, ainsi que l'effet de l'exécution de ces opérations.
L'ensemble des opérations $\trm{Op}_T$ et l'ensemble des valeurs de retour des opérations d'interrogations $\trm{Val}_T$ d'un type abstrait de données $T$ constituent la \emph{signature syntaxique} de $T$.
Cette signature syntaxique est couplée à une sémantique qui détermine les effets de l'exécution des opérations de modification sur les valeurs retournées par l'exécution d'opérations d'interrogation.
La sémantique du type abstrait de données est spécifiée par un modèle de cohérence.
Elle est donc formulée à l'aide d'un ensemble de propriétés de cohérence.

Prenons l'exemple du type abstrait de données \emph{Ensemble} noté $\trm{Set}\tuple*{V}$.
$V$ est l'ensemble des valeurs que l'ensemble peut contenir.
La \autoref{fig:set-spec} présente une spécification algébrique~\autocite{wirsing1990_algebraicspec} de ce type.
Nous proposons de l'adapter au formalisme utilisé dans ce manuscrit.
Les opérations de ce type regroupent une opération de lecture $\trm{rd}$, une opération d'ajout $\trm{add}(v)$, et une opération de suppression $\trm{rmv}(v)$ tel que $v$ est une valeur de l'ensemble $V$.
Les valeurs de retour de l'opération de lecture sont l'ensemble des parties finies de $V$~: $\trm{Val}_{\trm{Set}\tuple*{V}} = \powerfset{V}$.
La sémantique de ce type est précisé par la propriété de cohérence de l'\autoref{eq:add-win-set}.
Chaque valeur inclue dans l'ensemble retourné par l'exécution d'une opération de lecture est ajoutée par au moins une opération du contexte de l'opération de lecture et n'est pas visible à une opération du contexte de l'opération de lecture qui la supprime.

\begin{equation}\begin{split}\label{eq:add-win-set}
\MoveEqLeft x \in A \land \trm{call}(x) = \trm{rd} \implies \trm{rval}(x) =\\
    &\set*{v \given \exists y \in \trm{ctx}_A(x) \qsep \trm{call}(y) = \trm{add}(v) \land \nexists z \in \trm{ctx}_A(x) \qsep y \vis z \land \trm{call}(z) = \trm{rmv}(v)}
\end{split}\end{equation}

Cette propriété de cohérence est insuffisante pour caractériser la sémantique du type Ensemble.
En effet, les types usuels supposent des exécutions séquentielles.
Ils supposent donc un modèle de cohérence séquentiel dans lequel la relation de visibilité est un ordre total strict.

\begin{figure}[tb]
    \centering
    \begin{align*}
    &S \in \trm{Set}\tuple*{V}\\
    &\\
    &\trm{emp}: S\\
    &\trm{rd}: S \to \powerfset{V}\\
    &\trm{add}: S \times V \to S\\
    &\trm{rmv}: S \times V \to S\\
    &\\
    &\trm{rd}(\trm{emp}) = \emptyset \\
    &\trm{rd}(\trm{add}(s, v)) = \set*{v} \cup \trm{rd}(s) \\
    &\trm{add}(\trm{add}(s, v), v) = \trm{add}(s, v) \tag{\small add idempotence}\\
    &\trm{add}(\trm{add}(s, v_1), v_2) = \trm{add}(\trm{add}(s, v_2), v_1) \tag{\small add commutativity}\\
    &\trm{rmv}(\trm{emp}, v) = \trm{emp}\\
    &\trm{rmv}(\trm{add}(s, v), v) = s\\
    &\trm{rmv}(\trm{add}(s, v_1), v_2) = \trm{add}(\trm{rmv}(s, v_2), v_1) \tag{\small add/rmv commutativity}\\
    &\trm{rmv}(\trm{rmv}(s, v_1), v_2) = \trm{rmv}(\trm{rmv}(s, v_2), v_1) \tag{\small rmv commutativity}\\
    \end{align*}
    \caption[Spécification algébrique du type abstrait \emph{Ensemble}]{Spécification algébrique du type abstrait de données usuel \emph{Ensemble}.
    $\powerfset{V}$ désigne l'ensemble des parties finies de $V$.}\label{fig:set-spec}
\end{figure}

Le type abstrait de données Ensemble est spécifié pour une exécution séquentielle.
Cette sémantique est suffisante aussi longtemps que des modifications parallèles ne surviennent pas.
Les \acp{CRDT} sont répliqués et peuvent être modifiés en parallèle par plusieurs pairs.
Les types abstraits de données qui spécifient les \acp{CRDT} doivent donc à la fois spécifier l'effet des opérations et de leur combinaison pour des exécutions séquentielles et des exécutions concurrentes.
Ces types abstraits de données sont nommés \emph{types abstraits de données répliquées}~\autocite{roh_2011_rga}.
La majorité des \acp{CRDT} sont des extensions de types abstraits de données définit pour des exécutions séquentielles.
Ils se comportent donc de la même manière lorsqu'ils sont utilisés dans une exécution séquentielle.
Il s'agit d'un comportement recherché car il renvoie à une sémantique usuelle pour ses utilisateur·ice·s~\autocite{preguia2018_crdt}.
Dans ce manuscrit, nous considérons uniquement des \acp{CRDT} qui présentent ce comportement.

\begin{figure}[htb]
\centering
\begin{subfigure}{0.49\linewidth}
    \centering
    \begin{tikzpicture}
        \newcommand\hsep{1.4}
        \newcommand\vsep{-1.2}
        % Peers
        \path node (A) {}
        ;
        % Timeline ends
        \path (5*\hsep,0) coordinate (aend)
        ;
        % Events
        \path (A)
            to +(1*\hsep,0) node[
                label={below:$\trm{add}(1)$}
            ] (b1) {$b_1$}
            to +(2*\hsep,0) node[
                label={above:$\trm{add}(1)$}
            ] (a1) {$a_1$}
            to +(3*\hsep,0) node[
                label={below:$\trm{rmv}(1)$}
            ] (b2) {$b_2$}
            to +(4*\hsep,0) node[
                label={above:$\trm{rd} \emptyset$}
            ] (a2) {$a_2$}
        ;
        % Timelines
        \foreach \src/\dest in {A/b1,a2/aend}
            \draw (\src) edge[timeline] (\dest);
        % Precedence
        \foreach \src/\dest in {b1/a1,a1/b2,b2/a2}
            \draw[pre] (\src) to (\dest);
    \end{tikzpicture}
    \caption{}
\end{subfigure}
\begin{subfigure}{0.49\linewidth}
    \centering
    \begin{tikzpicture}
        \newcommand\hsep{1.4}
        \newcommand\vsep{-1.2}
        % Peers
        \path node (A) {}
        ;
        % Timeline ends
        \path (5*\hsep,0) coordinate (aend)
        ;
        % Events
        \path (A)
            to +(1*\hsep,0) node[
                label={above:$\trm{add}(1)$}
            ] (a1) {$a_1$}
            to +(2*\hsep,0) node[
                label={below:$\trm{add}(1)$}
            ] (b1) {$b_1$}
            to +(3*\hsep,0) node[
                label={below:$\trm{rmv}(1)$}
            ] (b2) {$b_2$}
            to +(4*\hsep,0) node[
                label={above:$\trm{rd} \emptyset$}
            ] (a2) {$a_2$}
        ;
        % Timelines
        \foreach \src/\dest in {A/a1,a2/aend}
            \draw (\src) edge[timeline] (\dest);
        % Precedence
        \foreach \src/\dest in {a1/b1,b1/b2,b2/a2}
            \draw[pre] (\src) to (\dest);
    \end{tikzpicture}
    \caption{}
\end{subfigure}
\par\medskip
\begin{subfigure}{\linewidth}
    \centering
    \begin{tikzpicture}
        \newcommand\hsep{1.4}
        \newcommand\vsep{-1.2}
        % Peers
        \path node (A) {}
        ;
        % Timeline ends
        \path (5*\hsep,0) coordinate (aend)
        ;
        % Events
        \path (A)
            to +(1*\hsep,0) node[
                label={below:$\trm{add}(1)$}
            ] (b1) {$b_1$}
            to +(2*\hsep,0) node[
                label={below:$\trm{rmv}(1)$}
            ] (b2) {$b_2$}
            to +(3*\hsep,0) node[
                label={above:$\trm{add}(1)$}
            ] (a1) {$a_1$}
            to +(4*\hsep,0) node[
                label={above:$\trm{rd} \set*{1}$}
            ] (a2) {$a_2$}
        ;
        % Timelines
        \foreach \src/\dest in {A/b1,a2/aend}
            \draw (\src) edge[timeline] (\dest);
        % Precedence
        \foreach \src/\dest in {b1/b2,b2/a1,a1/a2}
            \draw[pre] (\src) to (\dest);
    \end{tikzpicture}
    \caption{}
\end{subfigure}
\caption[Impact d'ordres distincts d'intégration des opérations de modification sur un ensemble répliqué]{Exécutions abstraites qui rend compte des ordres d'intégrations des opérations de l'exécution abstraite de la \autoref{fig:set-conflict-example}.}\label{fig:spec-linearization}
\end{figure}

La relation de visibilité rend compte des opérations dont l'effet a été intégré.
Dans la \autoref{fig:set-conflict-example}, les effets des opérations $a_1$, $b_1$, et $b_2$ sont intégrés avant l'exécution de l'opération de lecture $a_2$.
Étant donné que $b_1$ est visible à $b_2$, nous pouvons dire que $b_2$ a pris en compte l'effet de $b_1$.
Elle l'a d'autant pris en compte qu'elle annule l'effet de $b_1$.
L'effet de $b_1$ devrait donc être intégré avant $b_2$.
En revanche l'effet de $a_1$ peut être intégré avant $b_1$, entre $b_1$ et $b_2$, ou après $b_2$.
L'ordre d'intégration des effets des opérations peut changer la valeur retournée par $b_2$.
La \autoref{fig:spec-linearization} présente ces différents ordres d'intégration.
Nous constatons que certains ordres d'intégration distincts conduisent à des résultats identiques.
Intuitivement, si deux opérations sont commutatives, alors leurs effets peuvent être intégrés dans un ordre quelconque.
Dans le cas de l'ensemble, deux ajouts et deux suppressions d'un même élément ou d'éléments distincts sont commutatifs.
En revanche l'ajout et la suppression d'un même élément ne sont pas des opérations commutatives.
Les opérations sont dites \emph{incompatibles}.
Leurs intentions sont incompatibles et conduisent à des conflits de modification si leurs effets sont intégrés dans des ordres distincts.
Une sémantique doit donc définir un ordre d'intégration des effets des couples d'opérations incompatibles.
Puisque cet ordre est déterminé par la sémantique, nous disons que la résolution de conflits est déterministe.

Contrairement aux types abstraits usuels, plusieurs sémantiques peuvent se révéler utiles et dépendre de leur domaine d'application.
La littérature a par exemple proposé les sémantiques suivantes pour les ensembles répliqués~:

\begin{figure}[htb]
\centering
\begin{subfigure}{\linewidth}
    \centering
    \begin{tikzpicture}
        \newcommand\hsep{1.4}
        \newcommand\vsep{-1.2}
        % Peers
        \path node (A) {$p_A$}
            to +(0,1*\vsep) node (B) {$p_B$}
        ;
        % Timeline ends
        \path (10*\hsep,0) coordinate (aend)
            to +(0,1*\vsep) coordinate (bend)
        ;
        % Events
        \path (A)
            to +(1*\hsep,0) node[
                label={above:$\trm{add}(1)$}
            ] (a1) {$a_1$}
            to +(3*\hsep,0) node[
                label={above:$\trm{add}(2)$}
            ] (a2) {$a_2$}
            to +(5*\hsep,0) node[
                label={above:$\trm{rmv}(1)$}
            ] (a3) {$a_3$}
            to +(7*\hsep,0) node[
                label={above:$\trm{rmv}(2)$}
            ] (a4) {$a_4$}
            to +(9*\hsep,0) node[
                label={above:$\trm{rd} ?$}
            ] (a5) {$a_5$}
        ;
        \path (B)
            to +(2*\hsep,0) node[
                label={below:$\trm{rmv}(1)$}
            ] (b1) {$b_1$}
            to +(4*\hsep,0) node[
                label={below:$\trm{add}(1)$}
            ] (b2) {$b_2$}
            to +(8*\hsep,0) node[
                label={below:$\trm{add}(2)$}
            ] (b3) {$b_3$}
        ;
        % Timelines
        \foreach \src/\dest in {A/a1,a5/aend,B/b1,b3/bend}
            \draw (\src) edge[timeline] (\dest);
        % Precedence
        \foreach \src/\dest in {a1/a2,a2/a3,a3/a4,a4/a5,a1/b1,b1/b2,b2/b3,b3/a5}
            \draw[pre] (\src) to (\dest);
    \end{tikzpicture}
    \caption{}\label{fig:set-alt-sem-1}
\end{subfigure}
\par\medskip
\begin{subfigure}{\linewidth}
    \centering
    \begin{tabular}{cc}
        Sémantique & $\trm{rval}(a_5)$ \\
        \toprule
        \emph{Last-Writer-Win (LWW)} & $\set*{2}$ \\
        \emph{Add-Win (AW)} & $\set*{1,2}$ \\
        \emph{Remove-Win (RW)} & $\emptyset$ \\
        \emph{Causal-Length (CL)} & $\set*{1}$ \\
    \end{tabular}
    \caption{}\label{fig:set-alt-sem-2}
\end{subfigure}
\caption[Sémantiques d'un ensemble répliqué]{Illustration des différentes sémantiques d'un ensemble répliqué d'entiers.
\subref{fig:set-alt-sem-1} L'exécution abstraite considérée respecte le modèle de cohérence causale.
\subref{fig:set-alt-sem-2} La valeur de retour de l'opération de lecture $a_5$ dépend de la sémantique choisit pour l'ensemble répliqué.
}\label{fig:set-alt-sem}
\end{figure}

\paragraph{Un Last-Writer-Win Set (LWWSet)~\autocite{shapiro2011_comprehensive}} spécifie que la dernière opération l'emporte sur les précédentes. Les opérations sont ainsi estampées par un horodatage.
Si deux opérations ont le même horodatage, un ordre total strict sur les identifiants des pairs peut être utilisé pour lever l'ambiguïté.
Dans la \autoref{fig:set-alt-sem}, nous supposons qu'une première opération qui retourne-avant une seconde opération a un horodatage strictement plus petit que l'horodatage de la seconde opération.
Pour déterminer la composition de l'ensemble retourné par l'exécution de l'opération de lecture $a_5$, nous conservons uniquement l'opération avec l'horodatage le plus grand pour chaque valeur ajoutée au moins une fois dans l'ensemble.
Pour les valeurs $1$ et $2$, il s'agit respectivement de l'opération $a_3$ et $b_3$.
La valeur est présente dans l'ensemble lu si et seulement si l'opération conservée est un ajout.
L'ensemble lu est donc un singleton qui contient la valeur $2$.

\paragraph{Un Add-Win Set (AWSet)~\autocite{shapiro_2011_crdt}} spécifie que l'ajout d'un élément l'emporte toujours sur la suppression de ce même élément en parallèle.
Il est aussi connu sous le nom \emph{Observed-remove Set}~\autocite{shapiro_2011_crdt}.
Dans la \autoref{fig:set-alt-sem}, les ajouts $b_2$ et $b_3$ ne précédent pas de suppressions et prennent l'ascendance sur les suppressions concurrentes $a_3$ et $a_4$.
L'ensemble lu contient donc les valeurs $1$ et $2$.
Cette sémantique est spécifiée par l'\autoref{eq:add-win-set}.

\paragraph{Un Remove-Win Set (RWSet)} spécifie que la suppression d'un élément l'emporte toujours sur l'ajout de cette même valeur en parallèle.
Dans la \autoref{fig:set-alt-sem}, les suppressions $a_3$ et $a_4$ ne précédent pas d'ajouts et prennent l'ascendance sur les ajouts concurrents $b_2$ et $b_3$.
L'ensemble lu est donc vide.
Cette sémantique est spécifiée par l'\autoref{eq:remove-win-set}~:

\begin{equation}\begin{split}\label{eq:remove-win-set}
\MoveEqLeft x \in A \land \trm{call}(x) = \trm{rd} \implies \trm{rval}(x) =\\
    &\set*{v \given \exists y \in \trm{ctx}_A(x) \qsep \trm{call}(y) = \trm{add}(v) \land \nexists z \in \trm{ctx}_A(x) \qsep z \not\viseq y \land \trm{call}(z) = \trm{rmv}(v)}
\end{split}\end{equation}

\paragraph{Un Causal-Length Set (CLSet)~\autocite{yu2020_clset}} traite les successions d'ajouts et de suppressions d'une même valeur comme des annulations d'ajouts et de suppressions~\autocite{2019_yu_genericundo}.
Si un ajout ou une suppression est parallèle à une opération qui concerne la même valeur, alors l'effet de cette dernière est soit équivalente à la première, ou l'une d'entre elle annule ou prévale sur l'autre.
Dans la \autoref{fig:set-alt-sem}, les opérations $a_3$ et $b_1$ annulent l'effet de l'ajout $a_1$.
Elles sont donc équivalentes.
L'ajout $b_2$ annule l'effet de $b_1$.
Elle annule donc indirectement l'effet des opérations équivalentes à $b_1$, à savoir $a_3$.
En suivant le même principe on constate que $a_2$ et $b_3$ sont équivalentes.
$a_4$ annule l'effet de $a_2$ et $b_3$.
L'ensemble lu est donc un singleton qui contient la valeur $1$.

\paragraph{} Alors que les types abstraits usuels supposent le respect d'un modèle de cohérence séquentiel, les types abstraits de données répliquées respectent des modèles de cohérence plus faibles.
Les \acp{CRDT} respectent par conception la propriété de convergence forte.
Cette dernière est impliquée par leur sémantique.
En fonction du schéma de synchronisation choisit, les \acp{CRDT} peuvent respecter des modèles de cohérence plus fort.

%Nous représentons un \ac{CRDT} $T$ par un n-uplet $\tuple*{\trm{Op}_T, \trm{Val}_T}$ dans lequel $\trm{Op}_T$ est l'ensemble des opérations admises par le \ac{CRDT}, et $\trm{Val}_T$ est l'ensemble des valeurs de retour des opération d'interrogation.
%L'ensemble des opérations est l'union de l'ensemble $M$ des opérations de modifications et de l'ensemble $Q$ des opérations d'interrogations.
%Nous pouvons écrire $T \in \trm{CRDT}$ pour signaler que $T$ est un \ac{CRDT}.

%\paragraph{}Nous représentons un \ac{CRDT} par un n-uplet $\tuple*{S, M, Q}$ dans lequel $S$ est l'ensemble des états équipé d'un ensemble de requêtes $Q$, et d'un ensemble de modificateurs $M$.
%Un modificateur donne une version mise à jour de l'état, alors qu'une requête donne un type prédéfini.
%Les requêtes et les modificateurs prennent toujours un état comme premier paramètre.
%Nous écrivons $S : \trm{CRDT}$.

Les types abstraits de données répliquées permettent aux utilisateur·ice·s de se concentrer sur le comportement des contenus répliqués.
Les \acp{CRDT} s'appuie sur cette abstraction pour encapsuler les mécanismes de résolution de conflits.
La réplication optimiste d'un contenu partagé requiert la synchronisation des copies du contenu.
Les \acp{CRDT} proposent différentes stratégies de synchronisation que nous présentons dans la sous-section suivante.


\subsection{Schéma de synchronisation}\label{sec:crdt-sync}

Afin de converger, les pairs doivent intégrer l'ensemble des modifications effectuées sur les copies du contenu partagé.
Pour ce faire, les pairs s'échangent leurs modifications sous forme de messages.
Lorsqu'un pair exécute une opération, il génère un message qu'il intègre à sa copie et qu'il transmet aux autre pairs.
Les pairs intègrent à terme les messages qu'ils reçoivent.

La forme des messages conditionne la manière de synchroniser les copies du contenu partagé.
Il existe deux principales familles de \acp{CRDT}~: les \acp{CRDT} synchronisés par opérations, et les \acp{CRDT} synchronisés par états.
Nous présentons chaque famille de \acp{CRDT} et nous les illustrons à l'aide d'un ensemble répliqué.
L'ensemble répliqué choisit respecte la sémantique \emph{add-win} présentée dans la \autoref{sec:crdt-spec}.

Quel que soit le schéma de synchronisation choisit, les implémentations d'ensembles répliqués que nous présentons se basent sur une idée commune.
Chaque ajout d'une valeur dans l'ensemble associe à cette valeur un identifiant unique.
Si la valeur est ajoutée plusieurs fois dans l'ensemble, elle est donc associée à plusieurs identifiants.
Une suppression ne supprime pas directement une valeur mais supprime définitivement un ensemble d'identifiants qui lui est associée.
Une valeur est présente dans l'ensemble si elle est associée à au moins un identifiant.
L'utilisation d'identifiants uniques est courant dans les implémentations de \acp{CRDT}~\autocite{baquero_2018_pure-op-crdt,almeida_2018_delta-crdt-revisited}.
Ces identifiants sont généralement des couples dont le premier élément est l'identifiant unique du pair, et le second élément est un entier naturel qui est incrémenté avant chaque génération d'un nouvel identifiant.
Ce second élément est communément nommé \emph{nombre séquentiel}.
Ces couples sont dénommés \emph{dots}~\autocite{baquero_2018_pure-op-crdt}.

Pour décrire l'implémentation de ces ensembles répliqués, nous introduisons un formalisme inspirée des travaux de \textcite{baquero_2018_pure-op-crdt}.
Notre formalisme nous permet de décrire de manière unifiée les \acp{CRDT} synchronisés par opérations et les \acp{CRDT} synchronisés par états.
Une fois initialisé, un \ac{CRDT} peut être soumis aux événements d'entrés suivants~:
\begin{itemize}
\item L'exécution d'une opération d'interrogation
\item L'exécution d'une opération de modification
\item L'intégration d'un message d'un autre pair
\end{itemize}

Lorsqu'un pair exécute une opération d'interrogation, il évalue la valeur de retour de cette interrogation à l'aide de la fonction $\trm{eval}$.
%L'appel $\trm{eval}_i(s, x)$ donne la valeur de retour de l'exécution de l'opération d'interrogation $x$ par le pair $p_i$ sur un état $s$ du contenu partagé.
L'exécution d'une opération de modification se déroule en trois étapes.
Un message est d'abord généré à l'aide de la fonction $\trm{prepare}$.
%L'appel $\trm{prepare}_i(s, x)$ retourne le message généré par l'exécution de l'opération de modification $x$ par le pair $p_i$ sur l'état $s$.
Une fois généré, le message est intégré à la copie du pair à l'aide de la fonction $\trm{integrate}$.
%L'appel $\trm{integrate}_i(s, m)$ renvoie la mise-à-jour de l'état $s$ qui correspond à $s$ auquel a été intégré le message $m$ sur le pair $p_i$.
Finalement, le message est laissé à la charge d'un protocole de passage de messages qui peut transmettre immédiatement ou ultérieurement le message aux autres pairs.
L'intégration d'un message d'un autre pair s'effectue simplement à l'aide de la fonction $\trm{integrate}$.

L'implémentation des fonctions $\trm{eval}$, $\trm{prepare}$, et $\trm{integrate}$, ainsi que la spécification de l'ensemble des états suffisent à décrire l'implémentation d'un \ac{CRDT}.
La \autoref{tab:crdt-impl-func} donne la signature et la sémantique de ces fonctions.
Dans les paragraphes suivants nous détaillons les différences entre les différentes familles de \acp{CRDT}.

\begin{table}[htb]
\centering
\begin{tabular}{rp{0.7\linewidth}}
    $\trm{eval}_i(\sigma, x)$ & Retourne la valeur de retour de l'exécution de l'opération d'interrogation $x$ par le pair $p_i$ sur l'état $\sigma$ \\
    $\trm{prepare}_i(\sigma, x)$ & Retourne un message généré par l'exécution de l'opération de modification $x$ par le pair $p_i$ sur l'état $\sigma$ \\
    $\trm{integrate}_i(\sigma, m)$ & Retourne la mise-à-jour de l'état $\sigma$ qui correspond à $\sigma$ auquel a été intégré le message $m$ sur le pair $p_i$\\
\end{tabular}
\caption[Fonctions qui permettent d'implémenter un~\ac{CRDT}]{Fonctions qui permettent d'implémenter un~\ac{CRDT}.}\label{tab:crdt-impl-func}
\end{table}


\paragraph{Les \acp{CRDT} synchronisés par opérations~\autocite{baquero_2014_pure-op-crdt,baquero_2018_pure-op-crdt}} représentent les modifications effectuées sur une copie par des opérations intégrables.
Il est important de distinguer les opérations exécutées et les opérations intégrables.
L'exécution d'une opération de modification donne lieu à la génération d'un message qui encapsule une opération intégrable.
Par abus de langage nous pouvons parler d'opérations lorsque l'ambiguïté n'est pas possible.
Ces opérations peuvent être intégrées sur toutes les copies sans générer de conflits.
Toutefois elles ne peuvent pas être intégrées dans des ordres quelconques.
Il existe des relations de dépendances entre les opérations intégrables.

Les \acp{CRDT} synchronisés par opérations exigent un protocole de passage fiable de message~: chaque message doit être livré exactement une fois.
Cette famille de \acp{CRDT} requiert en général un ordre non-arbitraire de livraison des messages.
Ils supposent souvent une livraison causale des messages car elle garantit une cohérence causale des copies et elle simplifie leur implémentation.
En d'autres termes, si un pair intègre un message $x$ avant l'intégration d'un de ses propres messages $y$, alors $x$ doit toujours être intégré avant $y$ quel que soit la copie.
En pratique, la livraison causale d'opérations est difficile et peut entraîner des ralentissements de propagation des opérations dans l'ensemble du système~\autocite{alvisi_2017_writes-dirty-secret}.

%Le raffinement des \acp{CRDT} synchronisés par opérations conduit à la formulation d'une sous-famille qualifiée de pure~\autocite{baquero_2014_pure-op-crdt,baquero_2018_pure-op-crdt}.
%Dans cette sous-famille la génération du message est indépendant de l'état de la copie.
%Le message encapsule donc simplement l'opération exécutée.

\begin{figure}[bth]
\centering
\begin{align}
&\trm{OpAWSet}\tuple*{V} \defeq \powerfset{V \times \mathbb{I} \times \mathbb{N}^*} \times \mathbb{N}_0 \label{eq:op-awset-state}\\
%&s_0 \defeq \tuple*{\emptyset, 0}\\
&\trm{eval}_i(\tuple*{t, n}, \trm{rd}) \defeq \set*{v \given \tuple*{v, \_, \_} \in t} \label{eq:op-awset-eval}\\
&\trm{prepare}_i(\tuple*{t, n}, \trm{add}(v)) \defeq \tuple*{\trm{add}, \tuple*{v, i, n+1}} \label{eq:op-awset-prep-add}\\
&\trm{prepare}_i(\tuple*{t, n}, \trm{rmv}(v)) \defeq \tuple*{\trm{rmv}, \set*{\tuple*{v, \_, \_} \in t}} \label{eq:op-awset-prep-rmv}\\
&\begin{aligned}
\MoveEqLeft\trm{integrate}_i(\tuple*{m, n}, \tuple*{\trm{add}, \tuple*{v, j, n''}}) \defeq \tuple{t \cup \set*{\tuple*{v, j, n''}}, n'}\\
    &\where n' \defeq \begin{dcases}
        n'' & \when i = j\\
        n
    \end{dcases}
\end{aligned}\label{eq:op-awset-integr-add}\\
&\trm{integrate}_i(\tuple*{t, n}, \tuple*{\trm{rmv}, x}) \defeq \tuple*{t \sminus x, n} \label{eq:op-awset-integr-rmv}
\end{align}
\caption[Implémentation d'un ensemble répliqué synchronisé par opérations]{Implémentation d'un ensemble répliqué synchronisé par opérations qui respecte la sémantique \emph{Add-Win}.
La suppression d'une valeur doit être intégrée après l'intégration de son ajout.}\label{fig:op-add-win-set}
\end{figure}

\clearpage % better layout

\begin{figure}[tbh]
\centering
\begin{tikzpicture}
    \newcommand\hsep{1.4}
    \newcommand\vsep{-1.2}
    % Peers
    \path node (A) {$p_A$}
        to +(0,1*\vsep) node (B) {$p_B$}
    ;
    % Timeline ends
    \path (6*\hsep,0) coordinate (aend)
        to +(0,1*\vsep) coordinate (bend)
    ;
    % Events
    \path (A)
        to +(1*\hsep,0) node[
            label={above:$\trm{add}(1)$}
        ] (a1) {$a_1$}
        to +(3*\hsep,0) node[
            label={above:$\trm{rmv}(1)$}
        ] (a2) {$a_2$}
        to +(5*\hsep,0) node[
            label={above:$\trm{rd} \set{1}$}
        ] (a3) {$a_3$}
    ;
    \path (B)
        to +(2*\hsep,0) node[
            label={below:$\trm{add}(1)$}
        ] (b1) {$b_1$}
    ;
    % Timelines
    \foreach \src/\dest in {A/a1,a3/aend,B/b1,b1/bend}
        \draw (\src) edge[timeline] (\dest);
    % Precedence
    \foreach \src/\dest in {a1/a2,a1/b1,a2/a3,b1/a3}
        \draw[pre] (\src) to (\dest);
\end{tikzpicture}
\caption{Exécution abstraite qui respecte le modèle de cohérence causale.
Le contenu répliqué est un ensemble qui respecte la sémantique \emph{Add-Win}.}\label{fig:awset-example}
\end{figure}

La \autoref{fig:op-add-win-set} propose une implémentation d'un ensemble répliqué synchronisé par opérations.
L'\autoref{eq:op-awset-state} précise l'ensemble des états du \ac{CRDT}.
Un état est définit comme un couple $\tuple*{t, n}$ où $t$ contient l'ensemble des valeurs associées à leur identifiant unique et $n$ est un nombre séquentiel utilisé pour générer les identifiants uniques.
L'association d'une valeur $v$ et d'un identifiant $\tuple*{i, n'}$ est représentée par un triplet $\tuple*{v, i, n'}$ où $i$ est pris dans l'ensemble $\mathbb{I}$ des identifiants des pairs et $n'$ est un entier naturel non-nul ($n' \in \mathbb{N}^*$).
L'évaluation d'une opération de lecture retourne l'ensemble des valeurs enregistrées dans au moins un triplet (\autoref{eq:op-awset-eval}).
L'opération intégrable d'ajout d'une valeur correspond à un couple constitué de l'étiquette $\trm{add}$ et du triplet composé de la valeur et d'un nouvel identifiant unique (\autoref{eq:op-awset-prep-add}).
L'identifiant unique est formé par l'identifiant du pair qui génère l'opération intégrable et de son nombre séquentiel incrémenté d'une unité.
L'intégration d'une opération d'ajout consiste à ajouter le nouveau triplet et à incrémenter le nombre séquentiel si l'opération a été généré par le pair actuel (\autoref{eq:op-awset-integr-add}).
L'opération intégrable de suppression contient l'ensemble des triplets à supprimer et est estampillé par l'étiquette $\trm{rmv}$ (\autoref{eq:op-awset-prep-rmv}).
L'intégration de l'opération de suppression supprime les triplets qu'elle contient (\autoref{eq:op-awset-integr-rmv}).

\begin{figure}[bth]
\centering
\begin{tikzpicture}
    \newcommand\hsep{1.7}
    % Events
    \node (s0) {}
        to +(0,-\hsep) node (s1) {$\tuple*{\emptyset, 0}$}
        to +(0,-2*\hsep) node (s2) {$\tuple*{\set*{\tuple*{1,A_1}},1}$}
        to +(0,-3*\hsep) node (s3) {$\tuple*{\emptyset,1}$}
        to +(0,-4*\hsep) node (s4) {$\tuple*{\set*{\tuple*{1,B_1}},1}$}
        to +(0,-5*\hsep) node (s5) {$\tuple*{\set*{\tuple*{1,B_1}},1}$}
    ;
    % State transitions
    \draw[pre] (s0) to node[midway,left]{initialise} (s1);
    \draw[pre] (s1) to %
            node[midway,left]{exécute $a_1$} %
            node[midway,right]{génère $\tuple*{\trm{add},\tuple*{1,A_1}}$} %
        (s2);
    \draw[pre] (s2) to %
            node[midway,left]{exécute $a_2$} %
            node[midway,right]{génère $\tuple*{\trm{rmv},\set*{A_1}}$} %
        (s3);
    \draw[pre] (s3) to %
            node[midway,left]{intègre $\tuple*{\trm{add},\tuple*{1,B_1}}$} %
        (s4);
    \draw[pre] (s4) to %
            node[midway,left]{exécute $a_3$} %
            node[midway,right]{retourne $\set*{1}$} %
        (s5);
\end{tikzpicture}
\caption{États successifs de la copie du pair $p_A$ de l'exécution abstraite de la \autoref{fig:awset-example}.
L'ensemble répliqué utilise l'implémentation de la \autoref{fig:op-add-win-set}.}\label{fig:op-awset-state-trans}
\end{figure}

Nous prenons l'exécution abstraite de la \autoref{fig:awset-example} pour illustrer la réplication d'un ensemble qui utilise l'implémentation de la \autoref{fig:op-add-win-set}.
Le pair $p_A$ exécute une première opération $a_1$ qui ajoute la valeur $1$ à l'ensemble répliqué.
Il transmet sa modification au pair $p_B$.
$p_B$ intègre la modification de $p_A$ et exécute ensuite l'opération $b_1$ qui ajoute de nouveau la valeur $1$ dans l'ensemble.
Pendant ce temps, $p_A$ exécute l'opération $a_2$ qui supprime la valeur $1$.
$p_A$ reçoit et intègre la modification de $p_B$.
$p_A$ termine par l'exécution de l'opération de lecture $a_3$.
La \autoref{fig:op-awset-state-trans} décrit les états successifs de la copie du pair $p_A$.
Un triplet $\tuple*{v, i, n}$ et un identifiant $\tuple*{i, n}$ sont respectivement notés $\tuple*{v, i_n}$ et $i_n$.
Les arcs dirigés indiquent des transitions d'états.
Ils sont étiquetés à gauche des événements qui produisent les transitions d'états.
Lorsque l'événement correspond à l'exécution d'une opération de modification ou d'une opération d'interrogation, les arcs dirigés sont respectivement étiquetés à droite par le message généré et la valeur de retour.

%Une opération d'ajout est intégrée dès sa réception.
%En revanche, une opération de suppression est intégrée lorsque l'ensemble des triplets qu'elle contient ont été ajoutés (et éventuellement supprimés) de l'état.
%Une opération de suppression dépend donc sur les opérations qui ajoutent les triplets qu'elle contient.
%Par exemple la suppression $\tuple*{\trm{rmv}, \set*{\tuple*{1, A, 1}, \tuple*{1, B, 1}}}$ est intégrée lorsque les ajouts $\tuple*{\trm{add}, \tuple*{1, A, 1}}$ et $\tuple*{\trm{add}, \tuple*{1, B, 1}}$ ont été préalablement intégrés.

L'exécution d'une opération de suppression d'une valeur $v$ forme une opération intégrable qui contient l'ensemble des identifiants associés à $v$.
Si une opération d'ajout de $v$ est exécutée en parallèle, un nouvel identifiant est associé à la valeur.
Cet identifiant n'est pas inclut dans la suppression.
Quel que soit l'ordre d'intégration de ces deux opérations, la valeur $v$ sera présente dans l'ensemble.
L'implémentation décrite respecte donc la sémantique \emph{Add-Win}.


\paragraph{Les \acp{CRDT} synchronisés par états} transmettent directement l'état mis à jour au reste des pairs.
L'ensemble des messages et l'ensemble des états du \ac{CRDT} sont donc confondus.
Lorsqu'un pair reçoit l'état mis à jour d'un autre pair, il le fusionne avec l'état actuel de sa copie.
La fonction d'intégration $\trm{integrate}$ permet donc de fusionner deux états.
Les états peuvent être fusionnés dans un ordre arbitraire et plusieurs fois sans compromettre la convergence des copies.
La fonction d'intégration est par conséquent associative, commutative, et idempotente.

Les états sont partiellement ordonnés de telle manière à ce que la fusion de deux états produisent toujours un état plus grand que les états fusionnés ou égal à l'un des états fusionnés.
L'état obtenu est unique et minimal.
Il s'agit de la borne supérieure des états fusionnés.
AInsi un état fusionné avec lui même donne l'état lui-même.
La fusion d'un état $\sigma_1$ avec un état supérieur $\sigma_2$ donne $\sigma_2$.
Ces propriétés forment une structure algébrique connue.
En effet, l'ensemble des états équipé de la fonction d'intégration forme un sup-demi-treillis~\autocite{davey2002lattice}.
Chaque modification enfle l'état actuel pour obtenir un état qui lui est supérieur ou égal.
Ainsi si l'appel $\trm{prepare}_i(\sigma_1, \_)$ donne l'état $\sigma_2$, alors $\sigma_2$ est supérieur ou égal à $\sigma_2$ et leur fusion donne $\sigma_2$.

La propriété d'idempotence de la fusion et la propriété d'inflation d'une modification rendent les \acp{CRDT} synchronisés par états particulièrement adaptés aux systèmes de passage de messages non-fiables.
Elles permettent d'assurer la convergence à terme en dépit de la perte, du retard, de la duplication, ou du ré-ordonnement de messages.
Si des pairs ne reçoivent pas un état d'un pair, il suffit qu'ils reçoivent un état ultérieur de ce pair pour obtenir les modifications incluses dans l'état qu'ils n'ont pas reçu.
Leur manière de se synchroniser permet également au \ac{CRDT} d'être causalement cohérent.
Sur ce point, ils sont plus avantageux que les \acp{CRDT} synchronisés par opérations.
Lorsque la complexité spatiale d'un état est importante, les \acp{CRDT} synchronisés par états peuvent induire un coût de transmission non-négligeable.
Le coût peut être si élevé qu'un \ac{CRDT} synchronisé par opérations est préférable.

\begin{figure}[tb]
\centering
\begin{align}
&\trm{StateAWSet}\tuple*{V} \defeq \powerfset{V \times \mathbb{I} \times \mathbb{N}^*} \times \powerfset{\mathbb{I} \times \mathbb{N}^*} \label{eq:state-awset-state}\\
%&\bot \defeq \tuple*{\emptyset, \emptyset}\\
&\trm{eval}_i(\tuple*{t, c}, \trm{rd}) \defeq \set*{v \given \tuple*{v, \_, \_} \in t} \label{eq:state-awset-eval}\\
&\begin{aligned}
\MoveEqLeft\trm{prepare}_i(\tuple*{t, c}, \trm{add}(v)) \defeq \tuple*{t \cup \set*{\tuple*{v, i, n}},c \cup \tuple*{i, n}}\\
    &\where n \defeq 1 + \max(\set*{0,n \given \tuple*{i, n} \in c})
\end{aligned}\label{eq:state-awset-prep-add}\\
&\trm{prepare}_i(\tuple*{t, c}, \trm{rmv}(v)) \defeq \tuple*{t \sminus \set*{\tuple*{v, \_,\_} \in t},c} \label{eq:state-awset-prep-rmv}\\
&\begin{aligned}
\MoveEqLeft \trm{integrate}_i(\tuple*{t, c}, \tuple*{t', c'}) \defeq \tuple*{t'', c \cup c'}\\
    &\begin{aligned}
    \MoveEqLeft\where t'' \defeq (t \cap t')\\
    &\cup \set*{\tuple*{v, j, n} \in t \given \tuple*{j, n} \not\in c'}\\
    &\cup \set*{\tuple*{v', j', n'} \in t' \given \tuple*{j', n'} \not\in c}
    \end{aligned}
\end{aligned}\label{eq:state-awset-integr}
\end{align}
\caption[Implémentation d'un ensemble répliqué synchronisé par états]{Implémentation d'un ensemble répliqué synchronisé par états qui respecte la sémantique \emph{Add-Win}.}\label{fig:state-add-win-set}
\end{figure}

La \autoref{fig:state-add-win-set} présente une implémentation d'un ensemble répliqué synchronisé par états.
L'\autoref{eq:state-awset-state} précise l'ensemble des états du \ac{CRDT}.
Un état consiste en un couple $\tuple*{t,c}$ où $t$ est l'ensemble des valeurs associées à leur identifiant, et $c$ est l'ensemble des identifiants générés par les pairs.
Les associations de valeurs et d'identifiants sont représentées de la même manière que celles de l'ensemble répliqué synchronisé par opérations.
$c$ est le \emph{contexte causal }~\autocite{almeida_2018_delta-crdt-revisited} du \ac{CRDT}.
Il permet d'éviter d'ajouter ou de ré-ajouter une association qui a été supprimée.
%La suppression d'un triplet peut donc avoir lieu avant son ajout.
L’évaluation d’une opération de lecture retourne l’ensemble des valeurs enregistrées dans au moins un triplet (\autoref{eq:state-awset-eval}).
L'état généré par l'ajout d'une valeur correspond à l'ajout d'un nouveau triplet et de son identifiant au contexte causal (\autoref{eq:state-awset-prep-add}).
Le nouvel identifiant est formé par l'identifiant du pair qui exécute l'opération et le nombre séquentiel de ce pair incrémenté d'une unité.
Le nombre séquentiel d'un pair est obtenu à partir du contexte causal.
L'état généré par la suppression d'une valeur ne modifie pas le contexte causal et retire les triplets correspondants (\autoref{eq:state-awset-prep-rmv}).
Le contexte causal résultant de la fusion de deux états est l'union des contextes causaux des deux états (\autoref{eq:state-awset-integr}).
La formation de l'ensemble des triplets est un peu plus difficile.
Nous devons veiller à ne pas ajouter des triplets supprimés et à ajouter les triplets qui ne l'ont pas encore été dans l'un des états.
Un triplet est supprimé d'un état si son identifiant est présent dans son contexte causal.
Inversement un triplet n'a pas encore été ajouté dans un état si son identifiant est absent du contexte causal de l'état.
L'ensemble des triplets contient donc les triplets présents dans chaque état et les triplets de chaque état dont l'identifiant est absent du contexte causal de l'autre état.
En pratique le contexte causal peut être représenté par un vecteur de versions~\autocite{parker_1983_versionvector,mattern_1988_timevector}.

\begin{figure}[tbh]
\centering
\begin{tikzpicture}
    \newcommand\hsep{1.7}
    % Events
    \node (s0) {}
        to +(0,-\hsep) node (s1) {$\tuple*{\emptyset, \emptyset}$}
        to +(0,-2*\hsep) node (s2) {$\tuple*{\set*{\tuple*{1,A_1}},\set*{A_1}}$}
        to +(0,-3*\hsep) node (s3) {$\tuple*{\emptyset,\set*{A_1}}$}
        to +(0,-4*\hsep) node (s4) {$\tuple*{\set*{\tuple*{1,B_1}},\set*{A_1,B_1}}$}
        to +(0,-5*\hsep) node (s5) {$\tuple*{\set*{\tuple*{1,B_1}},\set*{A_1,B_1}}$}
    ;
    % State transitions
    \draw[pre] (s0) to node[midway,left]{initialise} (s1);
    \draw[pre] (s1) to %
            node[midway,left]{exécute $a_1$} %
            node[midway,right]{génère $\tuple*{\set*{\tuple*{1,A_1}},\set*{A_1}}$} %
        (s2);
    \draw[pre] (s2) to %
            node[midway,left]{exécute $a_2$} %
            node[midway,right]{génère $\tuple*{\emptyset,\set*{A_1}}$} %
        (s3);
    \draw[pre] (s3) to %
            node[midway,left]{intègre $\tuple*{\set*{\tuple*{1,A_1},\tuple*{1,B_1}},\set*{A_1,B_1}}$} %
        (s4);
    \draw[pre] (s4) to %
            node[midway,left]{exécute $a_3$} %
            node[midway,right]{retourne $\set*{1}$} %
        (s5);
\end{tikzpicture}
\caption{États successifs de la copie du pair $p_A$ de l'exécution abstraite de la \autoref{fig:awset-example}.
L'ensemble répliqué utilise l'implémentation de la \autoref{fig:state-add-win-set}.}\label{fig:state-awset-state-trans}
\end{figure}

Nous prenons l’exécution abstraite de la Figure \autoref{fig:awset-example} pour illustrer la réplication d’un ensemble qui utilise l’implémentation de la \autoref{fig:state-add-win-set}.
La \autoref{fig:state-awset-state-trans} décrit les états successifs de la copie du pair $p_A$.
La \autoref{fig:state-add-win-set-semilattice} présente le sup-demi-treillis des états de cette exécution.
Les traits épaissis représente les transitions d'états du pair $p_A$.
La fusion de deux états correspond à leur borne supérieure dans le sup-demi treillis.
Ainsi la fusion des états $\tuple*{\emptyset,\set*{A_1}}$ et $\tuple*{\set*{\tuple*{1,A_1},\tuple*{1,B_1}},\set*{A_1,B_1}}$ produit l'état $\tuple*{\set*{\tuple*{1,B_1}},\set*{A_1,B_1}}$.

\begin{figure}[tbh]
\centering
\begin{tikzpicture}
    \newcommand\hsep{2.3}
    \newcommand\vsep{1.3}
    \node (bot) at (0,0) {$\tuple*{\emptyset, \emptyset}$};
    \node[draw,rounded corners] (A1) at (-\hsep,\vsep) {$\tuple*{\set*{\tuple*{1,A_1}}, \set*{A_1}}$};
    \node[draw,rounded corners] (B1) at (\hsep,\vsep) {$\tuple*{\set*{\tuple*{1,B_1}}, \set*{B_1}}$};
    \node[draw,rounded corners] (A1p) at (-2*\hsep,2*\vsep) {$\tuple*{\emptyset, \set*{A_1}}$};
    %\node[draw,rounded corners] (B1p) at (2*\hsep,2*\vsep) {$\tuple*{\emptyset, \set*{B_1}}$};
    \node (A1B1) at (0,2*\vsep) {$\tuple*{\set*{\tuple*{1,A_1}, \tuple*{1,B_1}}, \set*{A_1, B_1}}$};
    \node (A1pB1) at (-\hsep,3*\vsep) {$\tuple*{\set*{\tuple*{1,B_1}}, \set*{A_1,B_1}}$};
    %\node (A1B1p) at (\hsep,3*\vsep) {$\tuple*{\set*{\tuple*{1,A_1}}, \set*{A_1,B_1}}$};
    %\node (A1pB1p) at (0,4*\vsep) {$\tuple*{\emptyset, \set*{A_1,B_1}}$};
    \draw[ultra thick] (bot) to (A1);
    \draw (bot) to (B1);
    \draw[ultra thick] (A1) to (A1p);
    %\draw (B1) to (B1p);
    \draw (A1) to (A1B1);
    \draw (B1) to (A1B1);
    \draw[ultra thick] (A1p) to (A1pB1);
    %\draw (B1p) to (A1B1p);
    \draw (A1B1) to (A1pB1);
    %\draw (A1B1) to (A1B1p);
    %\draw (A1pB1) to (A1pB1p);
    %\draw (A1B1p) to (A1pB1p);
\end{tikzpicture}
\caption[Aperçu d'un sup-demi-treillis d'un ensemble synchronisé par états]{Diagramme de Hasse du sup-demi-treillis des états de l'ensemble synchronisé par états de l'exécution de la \autoref{fig:awset-example}.
Les états entourés sont irréductibles.
}\label{fig:state-add-win-set-semilattice}
\end{figure}

\clearpage % better layout

\paragraph{Les \acp{CRDT} synchronisés par différences}~\autocite{almeida_2018_delta-crdt-revisited} sont une sous-famille des \acp{CRDT} synchronisés par états.
Ils permettent la conception de mécanismes de synchronisation plus efficaces~\autocite{enes_2018_efficient-sync-state-based-crdt}.
Ils reposent sur l'idée de décomposer un état en un ensemble d'états irréductibles.
Un état est irréductible si et seulement si il ne peut pas être obtenu par la fusion de deux états distincts et si il ne correspond pas à un état minimal (un état qui est inférieur à tout autre état).
Dans la \autoref{fig:state-add-win-set-semilattice}, les états irréductibles sont entourés.
L'état minimal est $\tuple*{\emptyset, \emptyset}$.
Un état décomposé peut être obtenu par la fusion de l'ensemble de ses états irréductibles.
Par exemple, l'état $\tuple*{\set*{\tuple*{1,B_1}}, \set*{A_1,B_1}}$ est obtenu par la fusion des deux états irréductibles $\tuple*{\emptyset, \set*{A_1}}$ et $\tuple*{\set*{\tuple*{1,B_1}}, \set*{B_1}}$.
Au lieu de transmettre aux autres pairs un état mis à jour dans son intégralité, un pair peut transmettre la différence entre un état mis à jour et sa version précédente.
Dans la littérature, plusieurs mécanismes de synchronisation par différences d'états prennent avantage de cette observation.
Certains d'entre eux permettent d'assurer une cohérence causale avec un sur-coût plus faible que les mécanismes de synchronisation par état complet~\autocite{enes_2018_efficient-sync-state-based-crdt}.
La flexibilité de cette approche permet la conception de mécanismes de synchronisation variés et est donc adaptée à un large éventail d'applications.

Comparé aux \ac{CRDT} synchronisé par états complets, l'appel à la fonction $\trm{prepare}$ ne retourne pas l'état mis-à-jour mais une différence d'état.
Bien que ce ne soit pas nécessaire, nous supposons que cette différence est minimale.
En d'autres termes nous ne pouvons trouver un autre état plus petit qui produit la même inflation.
Cette propriété n'est pas requise dans la définition originale des \ac{CRDT} synchronisés par différences d'états.
Elle a été introduire ultérieurement~\autocite{enes_2018_efficient-sync-state-based-crdt}.

La \autoref{fig:delta-awset} présente l'implémentation d'un ensemble répliqué synchronisé par différences d'états.
Elle est globalement identique à l'implémentation présentée dans la \autoref{fig:state-add-win-set}.
Seuls les messages générés sont distincts.
Les messages générés sont des états irréductibles.

\begin{figure}[bth]
\centering
\begin{align}
&\trm{DeltaAWSet}\tuple*{V} \defeq \powerfset{V \times \mathbb{I} \times \mathbb{N}^*} \times \powerfset{\mathbb{I} \times \mathbb{N}^*} \label{eq:delta-awset-state}\\
%&\bot \defeq \tuple*{\emptyset, \emptyset}\\
&\trm{eval}_i(\tuple*{t, c}, \trm{rd}) \defeq \set*{v \given \tuple*{v, \_, \_} \in t} \label{eq:delta-awset-eval}\\
&\begin{aligned}
\MoveEqLeft\trm{prepare}_i(\tuple*{t, c}, \trm{add}(v)) \defeq \tuple*{\tuple*{v, i, n},\set*{i, n}}\\
    &\where n \defeq 1 + \max(\set*{0,n \given \tuple*{i, n} \in c})
\end{aligned}\label{eq:delta-awset-prep-add}\\
&\trm{prepare}_i(\tuple*{t, c}, \trm{rmv}(v)) \defeq \tuple*{\emptyset, \set*{\tuple*{i, n} \given \tuple*{v, i, n} \in t}}\label{eq:delta-awset-prep-rmv}\\
&\begin{aligned}
\MoveEqLeft \trm{integrate}_i(\tuple*{t, c}, \tuple*{t', c'}) \defeq \tuple*{t'', c \cup c'}\\
    &\begin{aligned}
    \MoveEqLeft\where t'' \defeq (t \cap t')\\
    &\cup \set*{\tuple*{v, j, n} \in t \given \tuple*{j, n} \not\in c'}\\
    &\cup \set*{\tuple*{v', j', n'} \in t' \given \tuple*{j', n'} \not\in c}
    \end{aligned}
\end{aligned}\label{eq:delta-awset-integr}
\end{align}
\caption[Implémentation d'un ensemble répliqué synchronisé par différences d'états]{Implémentation d'un ensemble répliqué synchronisé par différences d'états qui respecte la sémantique \emph{Add-Win}.}\label{fig:delta-awset}
\end{figure}

Nous prenons de nouveau l'exécution abstraite de la \autoref{fig:awset-example} pour illustrer la réplication d'un ensemble qui utilise l'implémentation de la \autoref{fig:delta-awset}.
Le pair $p_A$ a exactement les mêmes transitions d'états que l'ensemble synchronisé par états complets.
Il génère les mêmes messages qui correspondent à des états irréductibles.
La \autoref{fig:state-awset-state-trans} représente donc les état successifs de la copie du pair $p_A$.
Dans cet exemple, le pair $p_B$ transmet à $p_A$ l'état $\tuple*{\set*{\tuple*{1,A_1},\tuple*{1,B_1}},\set*{A_1,B_1}}$.
La synchronisation par différences offre à $p_B$ plus de liberté.
Un autre protocole de synchronisation pourrait envoyer l'état irréductible $\tuple*{\set*{\tuple*{1,B_1}},\set*{B_1}}$.

Les \acp{CRDT} synchronisés par différences d'états conservent les avantages des \acp{CRDT} synchronisés par états tout en corrigeant leurs principaux défauts.
Avec un mécanisme de synchronisation adéquate, ils peuvent supporter la perte, les duplications, et l'intégration dans un ordre arbitraire des messages.
Ils ont la capacité de réduire le coût de transmission puisque seuls des différences d'états peuvent être transmises.


\paragraph{} Nous avons présenté les deux principales familles de \acp{CRDT}~: les \acp{CRDT} synchronisés par opérations et les \acp{CRDT} synchronisés par états.
Les \acp{CRDT} synchronisés par opérations exige un mécanisme de passage de message fiable et requiert l'intégration de certains messages dans un ordre spécifique au \ac{CRDT}.
Les \acp{CRDT} synchronisés par états sont moins exigeants et supportent les mécanismes de passage de message non-fiable avec une intégration de tous les messages dans un ordre quelconque.
Cependant, la taille des messages de certains \acp{CRDT} synchronisés par états peut être impraticable.
Les \acp{CRDT} synchronisés par différences d'états corrigent ce problème.
Au lieu de transmettre l'intégralité de l'état mis à jour, ils peuvent transmettre des différences d'états.
Dans le chapitre \autoref{ch:dotted-logootsplit} nous proposons un proposons un protocole synchronisé par différences d'états adapté à l'édition collaborative de texte.
